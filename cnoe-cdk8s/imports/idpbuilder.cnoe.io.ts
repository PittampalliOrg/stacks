// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 *
 *
 * @schema CustomPackage
 */
export class CustomPackage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "CustomPackage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'idpbuilder.cnoe.io/v1alpha1',
    kind: 'CustomPackage',
  }

  /**
   * Renders a Kubernetes manifest for "CustomPackage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: CustomPackageProps = {}): any {
    return {
      ...CustomPackage.GVK,
      ...toJson_CustomPackageProps(props),
    };
  }

  /**
   * Defines a "CustomPackage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: CustomPackageProps = {}) {
    super(scope, id, {
      ...CustomPackage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...CustomPackage.GVK,
      ...toJson_CustomPackageProps(resolved),
    };
  }
}

/**
 * @schema CustomPackage
 */
export interface CustomPackageProps {
  /**
   * @schema CustomPackage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * CustomPackageSpec controls the installation of the custom applications.
   *
   * @schema CustomPackage#spec
   */
  readonly spec?: CustomPackageSpec;

}

/**
 * Converts an object of type 'CustomPackageProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CustomPackageProps(obj: CustomPackageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_CustomPackageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CustomPackageSpec controls the installation of the custom applications.
 *
 * @schema CustomPackageSpec
 */
export interface CustomPackageSpec {
  /**
   * @schema CustomPackageSpec#argoCD
   */
  readonly argoCd?: CustomPackageSpecArgoCd;

  /**
   * @schema CustomPackageSpec#gitServerAuthSecretRef
   */
  readonly gitServerAuthSecretRef: CustomPackageSpecGitServerAuthSecretRef;

  /**
   * GitServerURL specifies the base URL for the git server for API calls.
   * for example, https://gitea.cnoe.localtest.me:8443
   *
   * @schema CustomPackageSpec#gitServerURL
   */
  readonly gitServerUrl: string;

  /**
   * InternalGitServeURL specifies the base URL for the git server accessible within the cluster.
   * for example, http://my-gitea-http.gitea.svc.cluster.local:3000
   *
   * @schema CustomPackageSpec#internalGitServeURL
   */
  readonly internalGitServeUrl: string;

  /**
   * RemoteRepositorySpec specifies information about remote repositories.
   *
   * @schema CustomPackageSpec#remoteRepository
   */
  readonly remoteRepository: CustomPackageSpecRemoteRepository;

  /**
   * Replicate specifies whether to replicate remote or local contents to the local gitea server.
   *
   * @schema CustomPackageSpec#replicate
   */
  readonly replicate: boolean;

}

/**
 * Converts an object of type 'CustomPackageSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CustomPackageSpec(obj: CustomPackageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'argoCD': toJson_CustomPackageSpecArgoCd(obj.argoCd),
    'gitServerAuthSecretRef': toJson_CustomPackageSpecGitServerAuthSecretRef(obj.gitServerAuthSecretRef),
    'gitServerURL': obj.gitServerUrl,
    'internalGitServeURL': obj.internalGitServeUrl,
    'remoteRepository': toJson_CustomPackageSpecRemoteRepository(obj.remoteRepository),
    'replicate': obj.replicate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CustomPackageSpecArgoCd
 */
export interface CustomPackageSpecArgoCd {
  /**
   * ApplicationFile specifies the absolute path to the ArgoCD application file
   *
   * @schema CustomPackageSpecArgoCd#applicationFile
   */
  readonly applicationFile: string;

  /**
   * @schema CustomPackageSpecArgoCd#name
   */
  readonly name: string;

  /**
   * @schema CustomPackageSpecArgoCd#namespace
   */
  readonly namespace: string;

  /**
   * @schema CustomPackageSpecArgoCd#type
   */
  readonly type: CustomPackageSpecArgoCdType;

}

/**
 * Converts an object of type 'CustomPackageSpecArgoCd' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CustomPackageSpecArgoCd(obj: CustomPackageSpecArgoCd | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'applicationFile': obj.applicationFile,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CustomPackageSpecGitServerAuthSecretRef
 */
export interface CustomPackageSpecGitServerAuthSecretRef {
  /**
   * @schema CustomPackageSpecGitServerAuthSecretRef#name
   */
  readonly name: string;

  /**
   * @schema CustomPackageSpecGitServerAuthSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'CustomPackageSpecGitServerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CustomPackageSpecGitServerAuthSecretRef(obj: CustomPackageSpecGitServerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRepositorySpec specifies information about remote repositories.
 *
 * @schema CustomPackageSpecRemoteRepository
 */
export interface CustomPackageSpecRemoteRepository {
  /**
   * @schema CustomPackageSpecRemoteRepository#cloneSubmodules
   */
  readonly cloneSubmodules: boolean;

  /**
   * @schema CustomPackageSpecRemoteRepository#path
   */
  readonly path: string;

  /**
   * Ref specifies the specific ref supported by git fetch
   *
   * @schema CustomPackageSpecRemoteRepository#ref
   */
  readonly ref: string;

  /**
   * Url specifies the url to the repository containing the ArgoCD application file
   *
   * @schema CustomPackageSpecRemoteRepository#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'CustomPackageSpecRemoteRepository' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_CustomPackageSpecRemoteRepository(obj: CustomPackageSpecRemoteRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloneSubmodules': obj.cloneSubmodules,
    'path': obj.path,
    'ref': obj.ref,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema CustomPackageSpecArgoCdType
 */
export enum CustomPackageSpecArgoCdType {
  /** Application */
  APPLICATION = "Application",
  /** ApplicationSet */
  APPLICATION_SET = "ApplicationSet",
}


/**
 *
 *
 * @schema GitRepository
 */
export class GitRepository extends ApiObject {
  /**
   * Returns the apiVersion and kind for "GitRepository"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'idpbuilder.cnoe.io/v1alpha1',
    kind: 'GitRepository',
  }

  /**
   * Renders a Kubernetes manifest for "GitRepository".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: GitRepositoryProps = {}): any {
    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(props),
    };
  }

  /**
   * Defines a "GitRepository" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: GitRepositoryProps = {}) {
    super(scope, id, {
      ...GitRepository.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...GitRepository.GVK,
      ...toJson_GitRepositoryProps(resolved),
    };
  }
}

/**
 * @schema GitRepository
 */
export interface GitRepositoryProps {
  /**
   * @schema GitRepository#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema GitRepository#spec
   */
  readonly spec?: GitRepositorySpec;

}

/**
 * Converts an object of type 'GitRepositoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositoryProps(obj: GitRepositoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_GitRepositorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GitRepositorySpec
 */
export interface GitRepositorySpec {
  /**
   * PackageCustomization defines how packages are customized
   *
   * @schema GitRepositorySpec#customization
   */
  readonly customization?: GitRepositorySpecCustomization;

  /**
   * @schema GitRepositorySpec#provider
   */
  readonly provider: GitRepositorySpecProvider;

  /**
   * SecretRef is the reference to secret that contain Git server credentials
   *
   * @schema GitRepositorySpec#secretRef
   */
  readonly secretRef?: GitRepositorySpecSecretRef;

  /**
   * @schema GitRepositorySpec#source
   */
  readonly source?: GitRepositorySpecSource;

}

/**
 * Converts an object of type 'GitRepositorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpec(obj: GitRepositorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'customization': toJson_GitRepositorySpecCustomization(obj.customization),
    'provider': toJson_GitRepositorySpecProvider(obj.provider),
    'secretRef': toJson_GitRepositorySpecSecretRef(obj.secretRef),
    'source': toJson_GitRepositorySpecSource(obj.source),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PackageCustomization defines how packages are customized
 *
 * @schema GitRepositorySpecCustomization
 */
export interface GitRepositorySpecCustomization {
  /**
   * FilePath is the absolute file path to a YAML file that contains Kubernetes manifests.
   *
   * @schema GitRepositorySpecCustomization#filePath
   */
  readonly filePath?: string;

  /**
   * Name is the name of the package to be customized. e.g. argocd
   *
   * @schema GitRepositorySpecCustomization#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'GitRepositorySpecCustomization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecCustomization(obj: GitRepositorySpecCustomization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filePath': obj.filePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GitRepositorySpecProvider
 */
export interface GitRepositorySpecProvider {
  /**
   * GitURL is the base URL of Git server used for API calls.
   *
   * @schema GitRepositorySpecProvider#gitURL
   */
  readonly gitUrl: string;

  /**
   * InternalGitURL is the base URL of Git server accessible within the cluster only.
   *
   * @schema GitRepositorySpecProvider#internalGitURL
   */
  readonly internalGitUrl: string;

  /**
   * @schema GitRepositorySpecProvider#name
   */
  readonly name: GitRepositorySpecProviderName;

  /**
   * @schema GitRepositorySpecProvider#organizationName
   */
  readonly organizationName: string;

}

/**
 * Converts an object of type 'GitRepositorySpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecProvider(obj: GitRepositorySpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'gitURL': obj.gitUrl,
    'internalGitURL': obj.internalGitUrl,
    'name': obj.name,
    'organizationName': obj.organizationName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef is the reference to secret that contain Git server credentials
 *
 * @schema GitRepositorySpecSecretRef
 */
export interface GitRepositorySpecSecretRef {
  /**
   * @schema GitRepositorySpecSecretRef#name
   */
  readonly name: string;

  /**
   * @schema GitRepositorySpecSecretRef#namespace
   */
  readonly namespace: string;

}

/**
 * Converts an object of type 'GitRepositorySpecSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecSecretRef(obj: GitRepositorySpecSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GitRepositorySpecSource
 */
export interface GitRepositorySpecSource {
  /**
   * @schema GitRepositorySpecSource#embeddedAppName
   */
  readonly embeddedAppName?: GitRepositorySpecSourceEmbeddedAppName;

  /**
   * Path is the absolute path to directory that contains Kustomize structure or raw manifests.
   * This is required when Type is set to local.
   *
   * @schema GitRepositorySpecSource#path
   */
  readonly path?: string;

  /**
   * RemoteRepositorySpec specifies information about remote repositories.
   *
   * @schema GitRepositorySpecSource#remoteRepository
   */
  readonly remoteRepository: GitRepositorySpecSourceRemoteRepository;

  /**
   * Type is the source type.
   *
   * @schema GitRepositorySpecSource#type
   */
  readonly type: GitRepositorySpecSourceType;

}

/**
 * Converts an object of type 'GitRepositorySpecSource' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecSource(obj: GitRepositorySpecSource | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'embeddedAppName': obj.embeddedAppName,
    'path': obj.path,
    'remoteRepository': toJson_GitRepositorySpecSourceRemoteRepository(obj.remoteRepository),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema GitRepositorySpecProviderName
 */
export enum GitRepositorySpecProviderName {
  /** gitea */
  GITEA = "gitea",
  /** github */
  GITHUB = "github",
}

/**
 * @schema GitRepositorySpecSourceEmbeddedAppName
 */
export enum GitRepositorySpecSourceEmbeddedAppName {
  /** argocd */
  ARGOCD = "argocd",
  /** gitea */
  GITEA = "gitea",
  /** nginx */
  NGINX = "nginx",
}

/**
 * RemoteRepositorySpec specifies information about remote repositories.
 *
 * @schema GitRepositorySpecSourceRemoteRepository
 */
export interface GitRepositorySpecSourceRemoteRepository {
  /**
   * @schema GitRepositorySpecSourceRemoteRepository#cloneSubmodules
   */
  readonly cloneSubmodules: boolean;

  /**
   * @schema GitRepositorySpecSourceRemoteRepository#path
   */
  readonly path: string;

  /**
   * Ref specifies the specific ref supported by git fetch
   *
   * @schema GitRepositorySpecSourceRemoteRepository#ref
   */
  readonly ref: string;

  /**
   * Url specifies the url to the repository containing the ArgoCD application file
   *
   * @schema GitRepositorySpecSourceRemoteRepository#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'GitRepositorySpecSourceRemoteRepository' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_GitRepositorySpecSourceRemoteRepository(obj: GitRepositorySpecSourceRemoteRepository | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cloneSubmodules': obj.cloneSubmodules,
    'path': obj.path,
    'ref': obj.ref,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Type is the source type.
 *
 * @schema GitRepositorySpecSourceType
 */
export enum GitRepositorySpecSourceType {
  /** local */
  LOCAL = "local",
  /** embedded */
  EMBEDDED = "embedded",
  /** remote */
  REMOTE = "remote",
}


/**
 *
 *
 * @schema Localbuild
 */
export class Localbuild extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Localbuild"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'idpbuilder.cnoe.io/v1alpha1',
    kind: 'Localbuild',
  }

  /**
   * Renders a Kubernetes manifest for "Localbuild".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: LocalbuildProps = {}): any {
    return {
      ...Localbuild.GVK,
      ...toJson_LocalbuildProps(props),
    };
  }

  /**
   * Defines a "Localbuild" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: LocalbuildProps = {}) {
    super(scope, id, {
      ...Localbuild.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Localbuild.GVK,
      ...toJson_LocalbuildProps(resolved),
    };
  }
}

/**
 * @schema Localbuild
 */
export interface LocalbuildProps {
  /**
   * @schema Localbuild#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema Localbuild#spec
   */
  readonly spec?: LocalbuildSpec;

}

/**
 * Converts an object of type 'LocalbuildProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildProps(obj: LocalbuildProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_LocalbuildSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema LocalbuildSpec
 */
export interface LocalbuildSpec {
  /**
   * BuildCustomizationSpec fields cannot change once a cluster is created
   *
   * @schema LocalbuildSpec#buildCustomization
   */
  readonly buildCustomization?: LocalbuildSpecBuildCustomization;

  /**
   * @schema LocalbuildSpec#packageConfigs
   */
  readonly packageConfigs?: LocalbuildSpecPackageConfigs;

}

/**
 * Converts an object of type 'LocalbuildSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildSpec(obj: LocalbuildSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'buildCustomization': toJson_LocalbuildSpecBuildCustomization(obj.buildCustomization),
    'packageConfigs': toJson_LocalbuildSpecPackageConfigs(obj.packageConfigs),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * BuildCustomizationSpec fields cannot change once a cluster is created
 *
 * @schema LocalbuildSpecBuildCustomization
 */
export interface LocalbuildSpecBuildCustomization {
  /**
   * @schema LocalbuildSpecBuildCustomization#host
   */
  readonly host?: string;

  /**
   * @schema LocalbuildSpecBuildCustomization#ingressHost
   */
  readonly ingressHost?: string;

  /**
   * @schema LocalbuildSpecBuildCustomization#port
   */
  readonly port?: string;

  /**
   * @schema LocalbuildSpecBuildCustomization#protocol
   */
  readonly protocol?: string;

  /**
   * @schema LocalbuildSpecBuildCustomization#selfSignedCert
   */
  readonly selfSignedCert?: string;

  /**
   * @schema LocalbuildSpecBuildCustomization#staticPassword
   */
  readonly staticPassword?: boolean;

  /**
   * @schema LocalbuildSpecBuildCustomization#usePathRouting
   */
  readonly usePathRouting?: boolean;

}

/**
 * Converts an object of type 'LocalbuildSpecBuildCustomization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildSpecBuildCustomization(obj: LocalbuildSpecBuildCustomization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'ingressHost': obj.ingressHost,
    'port': obj.port,
    'protocol': obj.protocol,
    'selfSignedCert': obj.selfSignedCert,
    'staticPassword': obj.staticPassword,
    'usePathRouting': obj.usePathRouting,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema LocalbuildSpecPackageConfigs
 */
export interface LocalbuildSpecPackageConfigs {
  /**
   * ArgoPackageConfigSpec Allows for configuration of the ArgoCD Installation.
   * If no fields are specified then the binary embedded resources will be used to install ArgoCD.
   *
   * @schema LocalbuildSpecPackageConfigs#argoPackageConfigs
   */
  readonly argoPackageConfigs?: LocalbuildSpecPackageConfigsArgoPackageConfigs;

  /**
   * @schema LocalbuildSpecPackageConfigs#customPackageDirs
   */
  readonly customPackageDirs?: string[];

  /**
   * @schema LocalbuildSpecPackageConfigs#customPackageUrls
   */
  readonly customPackageUrls?: string[];

  /**
   * EmbeddedArgoApplicationsPackageConfigSpec Controls the installation of the embedded argo applications.
   *
   * @schema LocalbuildSpecPackageConfigs#embeddedArgoApplicationsPackageConfigs
   */
  readonly embeddedArgoApplicationsPackageConfigs?: LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs;

  /**
   * @schema LocalbuildSpecPackageConfigs#packageCustomization
   */
  readonly packageCustomization?: { [key: string]: LocalbuildSpecPackageConfigsPackageCustomization };

}

/**
 * Converts an object of type 'LocalbuildSpecPackageConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildSpecPackageConfigs(obj: LocalbuildSpecPackageConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'argoPackageConfigs': toJson_LocalbuildSpecPackageConfigsArgoPackageConfigs(obj.argoPackageConfigs),
    'customPackageDirs': obj.customPackageDirs?.map(y => y),
    'customPackageUrls': obj.customPackageUrls?.map(y => y),
    'embeddedArgoApplicationsPackageConfigs': toJson_LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs(obj.embeddedArgoApplicationsPackageConfigs),
    'packageCustomization': ((obj.packageCustomization) === undefined) ? undefined : (Object.entries(obj.packageCustomization).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: toJson_LocalbuildSpecPackageConfigsPackageCustomization(i[1]) }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ArgoPackageConfigSpec Allows for configuration of the ArgoCD Installation.
 * If no fields are specified then the binary embedded resources will be used to install ArgoCD.
 *
 * @schema LocalbuildSpecPackageConfigsArgoPackageConfigs
 */
export interface LocalbuildSpecPackageConfigsArgoPackageConfigs {
  /**
   * Enabled controls whether to install ArgoCD.
   *
   * @schema LocalbuildSpecPackageConfigsArgoPackageConfigs#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LocalbuildSpecPackageConfigsArgoPackageConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildSpecPackageConfigsArgoPackageConfigs(obj: LocalbuildSpecPackageConfigsArgoPackageConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EmbeddedArgoApplicationsPackageConfigSpec Controls the installation of the embedded argo applications.
 *
 * @schema LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs
 */
export interface LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs {
  /**
   * Enabled controls whether to install the embedded argo applications and the associated GitServer
   *
   * @schema LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs#enabled
   */
  readonly enabled?: boolean;

}

/**
 * Converts an object of type 'LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs(obj: LocalbuildSpecPackageConfigsEmbeddedArgoApplicationsPackageConfigs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'enabled': obj.enabled,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PackageCustomization defines how packages are customized
 *
 * @schema LocalbuildSpecPackageConfigsPackageCustomization
 */
export interface LocalbuildSpecPackageConfigsPackageCustomization {
  /**
   * FilePath is the absolute file path to a YAML file that contains Kubernetes manifests.
   *
   * @schema LocalbuildSpecPackageConfigsPackageCustomization#filePath
   */
  readonly filePath?: string;

  /**
   * Name is the name of the package to be customized. e.g. argocd
   *
   * @schema LocalbuildSpecPackageConfigsPackageCustomization#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'LocalbuildSpecPackageConfigsPackageCustomization' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_LocalbuildSpecPackageConfigsPackageCustomization(obj: LocalbuildSpecPackageConfigsPackageCustomization | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'filePath': obj.filePath,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

