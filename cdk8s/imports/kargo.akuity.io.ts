// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterConfig is a resource type that describes cluster-level Kargo
configuration.
 *
 * @schema ClusterConfig
 */
export class ClusterConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'ClusterConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterConfigProps = {}): any {
    return {
      ...ClusterConfig.GVK,
      ...toJson_ClusterConfigProps(props),
    };
  }

  /**
   * Defines a "ClusterConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterConfigProps = {}) {
    super(scope, id, {
      ...ClusterConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterConfig.GVK,
      ...toJson_ClusterConfigProps(resolved),
    };
  }
}

/**
 * ClusterConfig is a resource type that describes cluster-level Kargo
 * configuration.
 *
 * @schema ClusterConfig
 */
export interface ClusterConfigProps {
  /**
   * @schema ClusterConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes the configuration of a cluster.
   *
   * @schema ClusterConfig#spec
   */
  readonly spec?: ClusterConfigSpec;

}

/**
 * Converts an object of type 'ClusterConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigProps(obj: ClusterConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes the configuration of a cluster.
 *
 * @schema ClusterConfigSpec
 */
export interface ClusterConfigSpec {
  /**
   * WebhookReceivers describes cluster-scoped webhook receivers used for
   * processing events from various external platforms
   *
   * @schema ClusterConfigSpec#webhookReceivers
   */
  readonly webhookReceivers?: ClusterConfigSpecWebhookReceivers[];

}

/**
 * Converts an object of type 'ClusterConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpec(obj: ClusterConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'webhookReceivers': obj.webhookReceivers?.map(y => toJson_ClusterConfigSpecWebhookReceivers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebhookReceiverConfig describes the configuration for a single webhook
 * receiver.
 *
 * @schema ClusterConfigSpecWebhookReceivers
 */
export interface ClusterConfigSpecWebhookReceivers {
  /**
   * Bitbucket contains the configuration for a webhook receiver that is
   * compatible with Bitbucket payloads.
   *
   * @schema ClusterConfigSpecWebhookReceivers#bitbucket
   */
  readonly bitbucket?: ClusterConfigSpecWebhookReceiversBitbucket;

  /**
   * DockerHub contains the configuration for a webhook receiver that is
   * compatible with DockerHub payloads.
   *
   * @schema ClusterConfigSpecWebhookReceivers#dockerhub
   */
  readonly dockerhub?: ClusterConfigSpecWebhookReceiversDockerhub;

  /**
   * GitHub contains the configuration for a webhook receiver that is compatible
   * with GitHub payloads.
   *
   * @schema ClusterConfigSpecWebhookReceivers#github
   */
  readonly github?: ClusterConfigSpecWebhookReceiversGithub;

  /**
   * GitLab contains the configuration for a webhook receiver that is compatible
   * with GitLab payloads.
   *
   * @schema ClusterConfigSpecWebhookReceivers#gitlab
   */
  readonly gitlab?: ClusterConfigSpecWebhookReceiversGitlab;

  /**
   * Name is the name of the webhook receiver.
   *
   * @schema ClusterConfigSpecWebhookReceivers#name
   */
  readonly name: string;

  /**
   * Quay contains the configuration for a webhook receiver that is compatible
   * with Quay payloads.
   *
   * @schema ClusterConfigSpecWebhookReceivers#quay
   */
  readonly quay?: ClusterConfigSpecWebhookReceiversQuay;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceivers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceivers(obj: ClusterConfigSpecWebhookReceivers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitbucket': toJson_ClusterConfigSpecWebhookReceiversBitbucket(obj.bitbucket),
    'dockerhub': toJson_ClusterConfigSpecWebhookReceiversDockerhub(obj.dockerhub),
    'github': toJson_ClusterConfigSpecWebhookReceiversGithub(obj.github),
    'gitlab': toJson_ClusterConfigSpecWebhookReceiversGitlab(obj.gitlab),
    'name': obj.name,
    'quay': toJson_ClusterConfigSpecWebhookReceiversQuay(obj.quay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bitbucket contains the configuration for a webhook receiver that is
 * compatible with Bitbucket payloads.
 *
 * @schema ClusterConfigSpecWebhookReceiversBitbucket
 */
export interface ClusterConfigSpecWebhookReceiversBitbucket {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose
   * value is the shared secret used to authenticate the webhook requests sent
   * by Bitbucket. For more information please refer to the Bitbucket
   * documentation:
   * https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/
   *
   * @schema ClusterConfigSpecWebhookReceiversBitbucket#secretRef
   */
  readonly secretRef: ClusterConfigSpecWebhookReceiversBitbucketSecretRef;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversBitbucket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversBitbucket(obj: ClusterConfigSpecWebhookReceiversBitbucket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterConfigSpecWebhookReceiversBitbucketSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DockerHub contains the configuration for a webhook receiver that is
 * compatible with DockerHub payloads.
 *
 * @schema ClusterConfigSpecWebhookReceiversDockerhub
 */
export interface ClusterConfigSpecWebhookReceiversDockerhub {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * The Secret's data map is expected to contain a `secret` key whose value
   * does NOT need to be shared directly with Docker Hub when registering a
   * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
   * which implicitly serves as a shared secret. For more information about
   * Docker Hub webhooks, please refer to the Docker documentation:
   * https://docs.docker.com/docker-hub/webhooks/
   *
   * @schema ClusterConfigSpecWebhookReceiversDockerhub#secretRef
   */
  readonly secretRef: ClusterConfigSpecWebhookReceiversDockerhubSecretRef;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversDockerhub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversDockerhub(obj: ClusterConfigSpecWebhookReceiversDockerhub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterConfigSpecWebhookReceiversDockerhubSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitHub contains the configuration for a webhook receiver that is compatible
 * with GitHub payloads.
 *
 * @schema ClusterConfigSpecWebhookReceiversGithub
 */
export interface ClusterConfigSpecWebhookReceiversGithub {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose value is
   * the shared secret used to authenticate the webhook requests sent by GitHub.
   * For more information please refer to GitHub documentation:
   * https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries
   *
   * @schema ClusterConfigSpecWebhookReceiversGithub#secretRef
   */
  readonly secretRef: ClusterConfigSpecWebhookReceiversGithubSecretRef;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversGithub(obj: ClusterConfigSpecWebhookReceiversGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterConfigSpecWebhookReceiversGithubSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab contains the configuration for a webhook receiver that is compatible
 * with GitLab payloads.
 *
 * @schema ClusterConfigSpecWebhookReceiversGitlab
 */
export interface ClusterConfigSpecWebhookReceiversGitlab {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The secret is expected to contain a `secret-token` key containing the
   * shared secret specified when registering the webhook in GitLab. For more
   * information about this token, please refer to the GitLab documentation:
   * https://docs.gitlab.com/user/project/integrations/webhooks/
   *
   * @schema ClusterConfigSpecWebhookReceiversGitlab#secretRef
   */
  readonly secretRef: ClusterConfigSpecWebhookReceiversGitlabSecretRef;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversGitlab(obj: ClusterConfigSpecWebhookReceiversGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterConfigSpecWebhookReceiversGitlabSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Quay contains the configuration for a webhook receiver that is compatible
 * with Quay payloads.
 *
 * @schema ClusterConfigSpecWebhookReceiversQuay
 */
export interface ClusterConfigSpecWebhookReceiversQuay {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose value
   * does NOT need to be shared directly with Quay when registering a
   * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
   * which implicitly serves as a shared secret. For more information about
   * Quay webhooks, please refer to the Quay documentation:
   * https://docs.quay.io/guides/notifications.html
   *
   * @schema ClusterConfigSpecWebhookReceiversQuay#secretRef
   */
  readonly secretRef: ClusterConfigSpecWebhookReceiversQuaySecretRef;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversQuay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversQuay(obj: ClusterConfigSpecWebhookReceiversQuay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterConfigSpecWebhookReceiversQuaySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose
 * value is the shared secret used to authenticate the webhook requests sent
 * by Bitbucket. For more information please refer to the Bitbucket
 * documentation:
 * https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/
 *
 * @schema ClusterConfigSpecWebhookReceiversBitbucketSecretRef
 */
export interface ClusterConfigSpecWebhookReceiversBitbucketSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterConfigSpecWebhookReceiversBitbucketSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversBitbucketSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversBitbucketSecretRef(obj: ClusterConfigSpecWebhookReceiversBitbucketSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * The Secret's data map is expected to contain a `secret` key whose value
 * does NOT need to be shared directly with Docker Hub when registering a
 * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
 * which implicitly serves as a shared secret. For more information about
 * Docker Hub webhooks, please refer to the Docker documentation:
 * https://docs.docker.com/docker-hub/webhooks/
 *
 * @schema ClusterConfigSpecWebhookReceiversDockerhubSecretRef
 */
export interface ClusterConfigSpecWebhookReceiversDockerhubSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterConfigSpecWebhookReceiversDockerhubSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversDockerhubSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversDockerhubSecretRef(obj: ClusterConfigSpecWebhookReceiversDockerhubSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose value is
 * the shared secret used to authenticate the webhook requests sent by GitHub.
 * For more information please refer to GitHub documentation:
 * https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries
 *
 * @schema ClusterConfigSpecWebhookReceiversGithubSecretRef
 */
export interface ClusterConfigSpecWebhookReceiversGithubSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterConfigSpecWebhookReceiversGithubSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversGithubSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversGithubSecretRef(obj: ClusterConfigSpecWebhookReceiversGithubSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The secret is expected to contain a `secret-token` key containing the
 * shared secret specified when registering the webhook in GitLab. For more
 * information about this token, please refer to the GitLab documentation:
 * https://docs.gitlab.com/user/project/integrations/webhooks/
 *
 * @schema ClusterConfigSpecWebhookReceiversGitlabSecretRef
 */
export interface ClusterConfigSpecWebhookReceiversGitlabSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterConfigSpecWebhookReceiversGitlabSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversGitlabSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversGitlabSecretRef(obj: ClusterConfigSpecWebhookReceiversGitlabSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose value
 * does NOT need to be shared directly with Quay when registering a
 * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
 * which implicitly serves as a shared secret. For more information about
 * Quay webhooks, please refer to the Quay documentation:
 * https://docs.quay.io/guides/notifications.html
 *
 * @schema ClusterConfigSpecWebhookReceiversQuaySecretRef
 */
export interface ClusterConfigSpecWebhookReceiversQuaySecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ClusterConfigSpecWebhookReceiversQuaySecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ClusterConfigSpecWebhookReceiversQuaySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterConfigSpecWebhookReceiversQuaySecretRef(obj: ClusterConfigSpecWebhookReceiversQuaySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 *
 *
 * @schema ClusterPromotionTask
 */
export class ClusterPromotionTask extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterPromotionTask"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'ClusterPromotionTask',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterPromotionTask".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterPromotionTaskProps): any {
    return {
      ...ClusterPromotionTask.GVK,
      ...toJson_ClusterPromotionTaskProps(props),
    };
  }

  /**
   * Defines a "ClusterPromotionTask" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterPromotionTaskProps) {
    super(scope, id, {
      ...ClusterPromotionTask.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterPromotionTask.GVK,
      ...toJson_ClusterPromotionTaskProps(resolved),
    };
  }
}

/**
 * @schema ClusterPromotionTask
 */
export interface ClusterPromotionTaskProps {
  /**
   * @schema ClusterPromotionTask#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes the desired transition of a specific Stage into a specific
   * Freight.
   *
   * @schema ClusterPromotionTask#spec
   */
  readonly spec: ClusterPromotionTaskSpec;

}

/**
 * Converts an object of type 'ClusterPromotionTaskProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskProps(obj: ClusterPromotionTaskProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterPromotionTaskSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes the desired transition of a specific Stage into a specific
 * Freight.
 *
 * @schema ClusterPromotionTaskSpec
 */
export interface ClusterPromotionTaskSpec {
  /**
   * Steps specifies the directives to be executed as part of this
   * PromotionTask. The steps as defined here are inflated into a
   * Promotion when it is built from a PromotionTemplate.
   *
   * @schema ClusterPromotionTaskSpec#steps
   */
  readonly steps: ClusterPromotionTaskSpecSteps[];

  /**
   * Vars specifies the variables available to the PromotionTask. The
   * values of these variables are the default values that can be
   * overridden by the step referencing the task.
   *
   * @schema ClusterPromotionTaskSpec#vars
   */
  readonly vars?: ClusterPromotionTaskSpecVars[];

}

/**
 * Converts an object of type 'ClusterPromotionTaskSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskSpec(obj: ClusterPromotionTaskSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'steps': obj.steps?.map(y => toJson_ClusterPromotionTaskSpecSteps(y)),
    'vars': obj.vars?.map(y => toJson_ClusterPromotionTaskSpecVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionStep describes a directive to be executed as part of a Promotion.
 *
 * @schema ClusterPromotionTaskSpecSteps
 */
export interface ClusterPromotionTaskSpecSteps {
  /**
   * As is the alias this step can be referred to as.
   *
   * @schema ClusterPromotionTaskSpecSteps#as
   */
  readonly as?: string;

  /**
   * Config is opaque configuration for the PromotionStep that is understood
   * only by each PromotionStep's implementation. It is legal to utilize
   * expressions in defining values at any level of this block.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema ClusterPromotionTaskSpecSteps#config
   */
  readonly config?: any;

  /**
   * ContinueOnError is a boolean value that, if set to true, will cause the
   * Promotion to continue executing the next step even if this step fails. It
   * also will not permit this failure to impact the overall status of the
   * Promotion.
   *
   * @schema ClusterPromotionTaskSpecSteps#continueOnError
   */
  readonly continueOnError?: boolean;

  /**
   * If is an optional expression that, if present, must evaluate to a boolean
   * value. If the expression evaluates to false, the step will be skipped.
   * If the expression does not evaluate to a boolean value, the step will be
   * considered to have failed.
   *
   * @schema ClusterPromotionTaskSpecSteps#if
   */
  readonly if?: string;

  /**
   * Retry is the retry policy for this step.
   *
   * @schema ClusterPromotionTaskSpecSteps#retry
   */
  readonly retry?: ClusterPromotionTaskSpecStepsRetry;

  /**
   * Task is a reference to a PromotionTask that should be inflated into a
   * Promotion when it is built from a PromotionTemplate.
   *
   * @schema ClusterPromotionTaskSpecSteps#task
   */
  readonly task?: ClusterPromotionTaskSpecStepsTask;

  /**
   * Uses identifies a runner that can execute this step.
   *
   * @schema ClusterPromotionTaskSpecSteps#uses
   */
  readonly uses?: string;

  /**
   * Vars is a list of variables that can be referenced by expressions in
   * the step's Config. The values override the values specified in the
   * PromotionSpec.
   *
   * @schema ClusterPromotionTaskSpecSteps#vars
   */
  readonly vars?: ClusterPromotionTaskSpecStepsVars[];

}

/**
 * Converts an object of type 'ClusterPromotionTaskSpecSteps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskSpecSteps(obj: ClusterPromotionTaskSpecSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as': obj.as,
    'config': obj.config,
    'continueOnError': obj.continueOnError,
    'if': obj.if,
    'retry': toJson_ClusterPromotionTaskSpecStepsRetry(obj.retry),
    'task': toJson_ClusterPromotionTaskSpecStepsTask(obj.task),
    'uses': obj.uses,
    'vars': obj.vars?.map(y => toJson_ClusterPromotionTaskSpecStepsVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema ClusterPromotionTaskSpecVars
 */
export interface ClusterPromotionTaskSpecVars {
  /**
   * Name is the name of the variable.
   *
   * @schema ClusterPromotionTaskSpecVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema ClusterPromotionTaskSpecVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterPromotionTaskSpecVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskSpecVars(obj: ClusterPromotionTaskSpecVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry is the retry policy for this step.
 *
 * @schema ClusterPromotionTaskSpecStepsRetry
 */
export interface ClusterPromotionTaskSpecStepsRetry {
  /**
   * ErrorThreshold is the number of consecutive times the step must fail (for
   * any reason) before retries are abandoned and the entire Promotion is marked
   * as failed.
   *
   * If this field is set to 0, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also 0), the effective
   * default will be the system-wide default of 1.
   *
   * A value of 1 will cause the Promotion to be marked as failed after just
   * a single failure; i.e. no retries will be attempted.
   *
   * There is no option to specify an infinite number of retries using a value
   * such as -1.
   *
   * In a future release, Kargo is likely to become capable of distinguishing
   * between recoverable and non-recoverable step failures. At that time, it is
   * planned that unrecoverable failures will not be subject to this threshold
   * and will immediately cause the Promotion to be marked as failed without
   * further condition.
   *
   * @schema ClusterPromotionTaskSpecStepsRetry#errorThreshold
   */
  readonly errorThreshold?: number;

  /**
   * Timeout is the soft maximum interval in which a step that returns a Running
   * status (which typically indicates it's waiting for something to happen)
   * may be retried.
   *
   * The maximum is a soft one because the check for whether the interval has
   * elapsed occurs AFTER the step has run. This effectively means a step may
   * run ONCE beyond the close of the interval.
   *
   * If this field is set to nil, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also nil), the effective
   * default will be the system-wide default of 0.
   *
   * A value of 0 will cause the step to be retried indefinitely unless the
   * ErrorThreshold is reached.
   *
   * @schema ClusterPromotionTaskSpecStepsRetry#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'ClusterPromotionTaskSpecStepsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskSpecStepsRetry(obj: ClusterPromotionTaskSpecStepsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorThreshold': obj.errorThreshold,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Task is a reference to a PromotionTask that should be inflated into a
 * Promotion when it is built from a PromotionTemplate.
 *
 * @schema ClusterPromotionTaskSpecStepsTask
 */
export interface ClusterPromotionTaskSpecStepsTask {
  /**
   * Kind is the type of the PromotionTask. Can be either PromotionTask or
   * ClusterPromotionTask, default is PromotionTask.
   *
   * @schema ClusterPromotionTaskSpecStepsTask#kind
   */
  readonly kind?: ClusterPromotionTaskSpecStepsTaskKind;

  /**
   * Name is the name of the (Cluster)PromotionTask.
   *
   * @schema ClusterPromotionTaskSpecStepsTask#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ClusterPromotionTaskSpecStepsTask' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskSpecStepsTask(obj: ClusterPromotionTaskSpecStepsTask | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema ClusterPromotionTaskSpecStepsVars
 */
export interface ClusterPromotionTaskSpecStepsVars {
  /**
   * Name is the name of the variable.
   *
   * @schema ClusterPromotionTaskSpecStepsVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema ClusterPromotionTaskSpecStepsVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterPromotionTaskSpecStepsVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterPromotionTaskSpecStepsVars(obj: ClusterPromotionTaskSpecStepsVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the type of the PromotionTask. Can be either PromotionTask or
 * ClusterPromotionTask, default is PromotionTask.
 *
 * @schema ClusterPromotionTaskSpecStepsTaskKind
 */
export enum ClusterPromotionTaskSpecStepsTaskKind {
  /** PromotionTask */
  PROMOTION_TASK = "PromotionTask",
  /** ClusterPromotionTask */
  CLUSTER_PROMOTION_TASK = "ClusterPromotionTask",
}


/**
 * Freight represents a collection of versioned artifacts.
 *
 * @schema Freight
 */
export class Freight extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Freight"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'Freight',
  }

  /**
   * Renders a Kubernetes manifest for "Freight".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: FreightProps): any {
    return {
      ...Freight.GVK,
      ...toJson_FreightProps(props),
    };
  }

  /**
   * Defines a "Freight" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: FreightProps) {
    super(scope, id, {
      ...Freight.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Freight.GVK,
      ...toJson_FreightProps(resolved),
    };
  }
}

/**
 * Freight represents a collection of versioned artifacts.
 *
 * @schema Freight
 */
export interface FreightProps {
  /**
   * @schema Freight#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Alias is a human-friendly alias for a piece of Freight. This is an optional
   * field. A defaulting webhook will sync this field with the value of the
   * kargo.akuity.io/alias label. When the alias label is not present or differs
   * from the value of this field, the defaulting webhook will set the label to
   * the value of this field. If the alias label is present and this field is
   * empty, the defaulting webhook will set the value of this field to the value
   * of the alias label. If this field is empty and the alias label is not
   * present, the defaulting webhook will choose an available alias and assign
   * it to both the field and label.
   *
   * @schema Freight#alias
   */
  readonly alias?: string;

  /**
   * Charts describes specific versions of specific Helm charts.
   *
   * @schema Freight#charts
   */
  readonly charts?: FreightCharts[];

  /**
   * Commits describes specific Git repository commits.
   *
   * @schema Freight#commits
   */
  readonly commits?: FreightCommits[];

  /**
   * Images describes specific versions of specific container images.
   *
   * @schema Freight#images
   */
  readonly images?: FreightImages[];

  /**
   * Origin describes a kind of Freight in terms of its origin.
   *
   * @schema Freight#origin
   */
  readonly origin: FreightOrigin;

}

/**
 * Converts an object of type 'FreightProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FreightProps(obj: FreightProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'alias': obj.alias,
    'charts': obj.charts?.map(y => toJson_FreightCharts(y)),
    'commits': obj.commits?.map(y => toJson_FreightCommits(y)),
    'images': obj.images?.map(y => toJson_FreightImages(y)),
    'origin': toJson_FreightOrigin(obj.origin),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Chart describes a specific version of a Helm chart.
 *
 * @schema FreightCharts
 */
export interface FreightCharts {
  /**
   * Name specifies the name of the chart.
   *
   * @schema FreightCharts#name
   */
  readonly name?: string;

  /**
   * RepoURL specifies the URL of a Helm chart repository. Classic chart
   * repositories (using HTTP/S) can contain differently named charts. When this
   * field points to such a repository, the Name field will specify the name of
   * the chart within the repository. In the case of a repository within an OCI
   * registry, the URL implicitly points to a specific chart and the Name field
   * will be empty.
   *
   * @schema FreightCharts#repoURL
   */
  readonly repoUrl?: string;

  /**
   * Version specifies a particular version of the chart.
   *
   * @schema FreightCharts#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'FreightCharts' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FreightCharts(obj: FreightCharts | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'repoURL': obj.repoUrl,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitCommit describes a specific commit from a specific Git repository.
 *
 * @schema FreightCommits
 */
export interface FreightCommits {
  /**
   * Author is the author of the commit.
   *
   * @schema FreightCommits#author
   */
  readonly author?: string;

  /**
   * Branch denotes the branch of the repository where this commit was found.
   *
   * @schema FreightCommits#branch
   */
  readonly branch?: string;

  /**
   * Committer is the person who committed the commit.
   *
   * @schema FreightCommits#committer
   */
  readonly committer?: string;

  /**
   * ID is the ID of a specific commit in the Git repository specified by
   * RepoURL.
   *
   * @schema FreightCommits#id
   */
  readonly id?: string;

  /**
   * Message is the message associated with the commit. At present, this only
   * contains the first line (subject) of the commit message.
   *
   * @schema FreightCommits#message
   */
  readonly message?: string;

  /**
   * RepoURL is the URL of a Git repository.
   *
   * @schema FreightCommits#repoURL
   */
  readonly repoUrl?: string;

  /**
   * Tag denotes a tag in the repository that matched selection criteria and
   * resolved to this commit.
   *
   * @schema FreightCommits#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'FreightCommits' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FreightCommits(obj: FreightCommits | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'author': obj.author,
    'branch': obj.branch,
    'committer': obj.committer,
    'id': obj.id,
    'message': obj.message,
    'repoURL': obj.repoUrl,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image describes a specific version of a container image.
 *
 * @schema FreightImages
 */
export interface FreightImages {
  /**
   * Annotations is a map of arbitrary metadata for the image.
   *
   * @schema FreightImages#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Digest identifies a specific version of the image in the repository
   * specified by RepoURL. This is a more precise identifier than Tag.
   *
   * @schema FreightImages#digest
   */
  readonly digest?: string;

  /**
   * GitRepoURL specifies the URL of a Git repository that contains the source
   * code for the image repository referenced by the RepoURL field if Kargo was
   * able to infer it.
   *
   * Deprecated: Use OCI annotations instead. Will be removed in v1.7.0.
   *
   * @schema FreightImages#gitRepoURL
   */
  readonly gitRepoUrl?: string;

  /**
   * RepoURL describes the repository in which the image can be found.
   *
   * @schema FreightImages#repoURL
   */
  readonly repoUrl?: string;

  /**
   * Tag identifies a specific version of the image in the repository specified
   * by RepoURL.
   *
   * @schema FreightImages#tag
   */
  readonly tag?: string;

}

/**
 * Converts an object of type 'FreightImages' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FreightImages(obj: FreightImages | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'digest': obj.digest,
    'gitRepoURL': obj.gitRepoUrl,
    'repoURL': obj.repoUrl,
    'tag': obj.tag,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Origin describes a kind of Freight in terms of its origin.
 *
 * @schema FreightOrigin
 */
export interface FreightOrigin {
  /**
   * Kind is the kind of resource from which Freight may have originated. At
   * present, this can only be "Warehouse".
   *
   * @schema FreightOrigin#kind
   */
  readonly kind: FreightOriginKind;

  /**
   * Name is the name of the resource of the kind indicated by the Kind field
   * from which Freight may originate.
   *
   * @schema FreightOrigin#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'FreightOrigin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_FreightOrigin(obj: FreightOrigin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the kind of resource from which Freight may have originated. At
 * present, this can only be "Warehouse".
 *
 * @schema FreightOriginKind
 */
export enum FreightOriginKind {
  /** Warehouse */
  WAREHOUSE = "Warehouse",
}


/**
 * Project is a resource type that reconciles to a specially labeled namespace
and other TODO: TBD project-level resources.
 *
 * @schema Project
 */
export class Project extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Project"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'Project',
  }

  /**
   * Renders a Kubernetes manifest for "Project".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectProps = {}): any {
    return {
      ...Project.GVK,
      ...toJson_ProjectProps(props),
    };
  }

  /**
   * Defines a "Project" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectProps = {}) {
    super(scope, id, {
      ...Project.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Project.GVK,
      ...toJson_ProjectProps(resolved),
    };
  }
}

/**
 * Project is a resource type that reconciles to a specially labeled namespace
 * and other TODO: TBD project-level resources.
 *
 * @schema Project
 */
export interface ProjectProps {
  /**
   * @schema Project#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes a Project.
   *
   * Deprecated: Create a ProjectConfig resource with the same name as the
   * Project resource in the Project's namespace. The ProjectConfig resource
   * can be used to configure the Project.
   *
   * @schema Project#spec
   */
  readonly spec?: ProjectSpec;

}

/**
 * Converts an object of type 'ProjectProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectProps(obj: ProjectProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes a Project.
 *
 * Deprecated: Create a ProjectConfig resource with the same name as the
 * Project resource in the Project's namespace. The ProjectConfig resource
 * can be used to configure the Project.
 *
 * @schema ProjectSpec
 */
export interface ProjectSpec {
  /**
   * PromotionPolicies defines policies governing the promotion of Freight to
   * specific Stages within the Project.
   *
   * @schema ProjectSpec#promotionPolicies
   */
  readonly promotionPolicies?: ProjectSpecPromotionPolicies[];

  /**
   * WebhookReceivers describes Project-specific webhook receivers used for
   * processing events from various external platforms
   *
   * @schema ProjectSpec#webhookReceivers
   */
  readonly webhookReceivers?: ProjectSpecWebhookReceivers[];

}

/**
 * Converts an object of type 'ProjectSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpec(obj: ProjectSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'promotionPolicies': obj.promotionPolicies?.map(y => toJson_ProjectSpecPromotionPolicies(y)),
    'webhookReceivers': obj.webhookReceivers?.map(y => toJson_ProjectSpecWebhookReceivers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionPolicy defines policies governing the promotion of Freight to a
 * specific Stage.
 *
 * @schema ProjectSpecPromotionPolicies
 */
export interface ProjectSpecPromotionPolicies {
  /**
   * AutoPromotionEnabled indicates whether new Freight can automatically be
   * promoted into the Stage referenced by the Stage field. Note: There are may
   * be other conditions also required for an auto-promotion to occur. This
   * field defaults to false, but is commonly set to true for Stages that
   * subscribe to Warehouses instead of other, upstream Stages. This allows
   * users to define Stages that are automatically updated as soon as new
   * artifacts are detected.
   *
   * @schema ProjectSpecPromotionPolicies#autoPromotionEnabled
   */
  readonly autoPromotionEnabled?: boolean;

  /**
   * Stage is the name of the Stage to which this policy applies.
   *
   * Deprecated: Use StageSelector instead.
   *
   * @schema ProjectSpecPromotionPolicies#stage
   */
  readonly stage?: string;

  /**
   * StageSelector is a selector that matches the Stage resource to which
   * this policy applies.
   *
   * @schema ProjectSpecPromotionPolicies#stageSelector
   */
  readonly stageSelector?: ProjectSpecPromotionPoliciesStageSelector;

}

/**
 * Converts an object of type 'ProjectSpecPromotionPolicies' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecPromotionPolicies(obj: ProjectSpecPromotionPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoPromotionEnabled': obj.autoPromotionEnabled,
    'stage': obj.stage,
    'stageSelector': toJson_ProjectSpecPromotionPoliciesStageSelector(obj.stageSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebhookReceiverConfig describes the configuration for a single webhook
 * receiver.
 *
 * @schema ProjectSpecWebhookReceivers
 */
export interface ProjectSpecWebhookReceivers {
  /**
   * Bitbucket contains the configuration for a webhook receiver that is
   * compatible with Bitbucket payloads.
   *
   * @schema ProjectSpecWebhookReceivers#bitbucket
   */
  readonly bitbucket?: ProjectSpecWebhookReceiversBitbucket;

  /**
   * DockerHub contains the configuration for a webhook receiver that is
   * compatible with DockerHub payloads.
   *
   * @schema ProjectSpecWebhookReceivers#dockerhub
   */
  readonly dockerhub?: ProjectSpecWebhookReceiversDockerhub;

  /**
   * GitHub contains the configuration for a webhook receiver that is compatible
   * with GitHub payloads.
   *
   * @schema ProjectSpecWebhookReceivers#github
   */
  readonly github?: ProjectSpecWebhookReceiversGithub;

  /**
   * GitLab contains the configuration for a webhook receiver that is compatible
   * with GitLab payloads.
   *
   * @schema ProjectSpecWebhookReceivers#gitlab
   */
  readonly gitlab?: ProjectSpecWebhookReceiversGitlab;

  /**
   * Name is the name of the webhook receiver.
   *
   * @schema ProjectSpecWebhookReceivers#name
   */
  readonly name: string;

  /**
   * Quay contains the configuration for a webhook receiver that is compatible
   * with Quay payloads.
   *
   * @schema ProjectSpecWebhookReceivers#quay
   */
  readonly quay?: ProjectSpecWebhookReceiversQuay;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceivers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceivers(obj: ProjectSpecWebhookReceivers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitbucket': toJson_ProjectSpecWebhookReceiversBitbucket(obj.bitbucket),
    'dockerhub': toJson_ProjectSpecWebhookReceiversDockerhub(obj.dockerhub),
    'github': toJson_ProjectSpecWebhookReceiversGithub(obj.github),
    'gitlab': toJson_ProjectSpecWebhookReceiversGitlab(obj.gitlab),
    'name': obj.name,
    'quay': toJson_ProjectSpecWebhookReceiversQuay(obj.quay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StageSelector is a selector that matches the Stage resource to which
 * this policy applies.
 *
 * @schema ProjectSpecPromotionPoliciesStageSelector
 */
export interface ProjectSpecPromotionPoliciesStageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ProjectSpecPromotionPoliciesStageSelector#matchExpressions
   */
  readonly matchExpressions?: ProjectSpecPromotionPoliciesStageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ProjectSpecPromotionPoliciesStageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name is the name of the resource to which this policy applies.
   *
   * It can be an exact name, a regex pattern (with prefix "regex:"), or a
   * glob pattern (with prefix "glob:").
   *
   * When both Name and LabelSelector are specified, the Name is ANDed with
   * the LabelSelector. I.e., the resource must match both the Name and
   * LabelSelector to be selected by this policy.
   *
   * NOTE: Using a specific exact name is the most secure option. Pattern
   * matching via regex or glob can be exploited by users with permissions to
   * match promotion policies that weren't intended to apply to their
   * resources. For example, a user could create a resource with a name
   * deliberately crafted to match the pattern, potentially bypassing intended
   * promotion controls.
   *
   * @schema ProjectSpecPromotionPoliciesStageSelector#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecPromotionPoliciesStageSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecPromotionPoliciesStageSelector(obj: ProjectSpecPromotionPoliciesStageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ProjectSpecPromotionPoliciesStageSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bitbucket contains the configuration for a webhook receiver that is
 * compatible with Bitbucket payloads.
 *
 * @schema ProjectSpecWebhookReceiversBitbucket
 */
export interface ProjectSpecWebhookReceiversBitbucket {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose
   * value is the shared secret used to authenticate the webhook requests sent
   * by Bitbucket. For more information please refer to the Bitbucket
   * documentation:
   * https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/
   *
   * @schema ProjectSpecWebhookReceiversBitbucket#secretRef
   */
  readonly secretRef: ProjectSpecWebhookReceiversBitbucketSecretRef;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversBitbucket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversBitbucket(obj: ProjectSpecWebhookReceiversBitbucket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectSpecWebhookReceiversBitbucketSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DockerHub contains the configuration for a webhook receiver that is
 * compatible with DockerHub payloads.
 *
 * @schema ProjectSpecWebhookReceiversDockerhub
 */
export interface ProjectSpecWebhookReceiversDockerhub {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * The Secret's data map is expected to contain a `secret` key whose value
   * does NOT need to be shared directly with Docker Hub when registering a
   * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
   * which implicitly serves as a shared secret. For more information about
   * Docker Hub webhooks, please refer to the Docker documentation:
   * https://docs.docker.com/docker-hub/webhooks/
   *
   * @schema ProjectSpecWebhookReceiversDockerhub#secretRef
   */
  readonly secretRef: ProjectSpecWebhookReceiversDockerhubSecretRef;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversDockerhub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversDockerhub(obj: ProjectSpecWebhookReceiversDockerhub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectSpecWebhookReceiversDockerhubSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitHub contains the configuration for a webhook receiver that is compatible
 * with GitHub payloads.
 *
 * @schema ProjectSpecWebhookReceiversGithub
 */
export interface ProjectSpecWebhookReceiversGithub {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose value is
   * the shared secret used to authenticate the webhook requests sent by GitHub.
   * For more information please refer to GitHub documentation:
   * https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries
   *
   * @schema ProjectSpecWebhookReceiversGithub#secretRef
   */
  readonly secretRef: ProjectSpecWebhookReceiversGithubSecretRef;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversGithub(obj: ProjectSpecWebhookReceiversGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectSpecWebhookReceiversGithubSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab contains the configuration for a webhook receiver that is compatible
 * with GitLab payloads.
 *
 * @schema ProjectSpecWebhookReceiversGitlab
 */
export interface ProjectSpecWebhookReceiversGitlab {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The secret is expected to contain a `secret-token` key containing the
   * shared secret specified when registering the webhook in GitLab. For more
   * information about this token, please refer to the GitLab documentation:
   * https://docs.gitlab.com/user/project/integrations/webhooks/
   *
   * @schema ProjectSpecWebhookReceiversGitlab#secretRef
   */
  readonly secretRef: ProjectSpecWebhookReceiversGitlabSecretRef;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversGitlab(obj: ProjectSpecWebhookReceiversGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectSpecWebhookReceiversGitlabSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Quay contains the configuration for a webhook receiver that is compatible
 * with Quay payloads.
 *
 * @schema ProjectSpecWebhookReceiversQuay
 */
export interface ProjectSpecWebhookReceiversQuay {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose value
   * does NOT need to be shared directly with Quay when registering a
   * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
   * which implicitly serves as a shared secret. For more information about
   * Quay webhooks, please refer to the Quay documentation:
   * https://docs.quay.io/guides/notifications.html
   *
   * @schema ProjectSpecWebhookReceiversQuay#secretRef
   */
  readonly secretRef: ProjectSpecWebhookReceiversQuaySecretRef;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversQuay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversQuay(obj: ProjectSpecWebhookReceiversQuay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectSpecWebhookReceiversQuaySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ProjectSpecPromotionPoliciesStageSelectorMatchExpressions
 */
export interface ProjectSpecPromotionPoliciesStageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ProjectSpecPromotionPoliciesStageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ProjectSpecPromotionPoliciesStageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ProjectSpecPromotionPoliciesStageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ProjectSpecPromotionPoliciesStageSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecPromotionPoliciesStageSelectorMatchExpressions(obj: ProjectSpecPromotionPoliciesStageSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose
 * value is the shared secret used to authenticate the webhook requests sent
 * by Bitbucket. For more information please refer to the Bitbucket
 * documentation:
 * https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/
 *
 * @schema ProjectSpecWebhookReceiversBitbucketSecretRef
 */
export interface ProjectSpecWebhookReceiversBitbucketSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectSpecWebhookReceiversBitbucketSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversBitbucketSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversBitbucketSecretRef(obj: ProjectSpecWebhookReceiversBitbucketSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * The Secret's data map is expected to contain a `secret` key whose value
 * does NOT need to be shared directly with Docker Hub when registering a
 * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
 * which implicitly serves as a shared secret. For more information about
 * Docker Hub webhooks, please refer to the Docker documentation:
 * https://docs.docker.com/docker-hub/webhooks/
 *
 * @schema ProjectSpecWebhookReceiversDockerhubSecretRef
 */
export interface ProjectSpecWebhookReceiversDockerhubSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectSpecWebhookReceiversDockerhubSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversDockerhubSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversDockerhubSecretRef(obj: ProjectSpecWebhookReceiversDockerhubSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose value is
 * the shared secret used to authenticate the webhook requests sent by GitHub.
 * For more information please refer to GitHub documentation:
 * https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries
 *
 * @schema ProjectSpecWebhookReceiversGithubSecretRef
 */
export interface ProjectSpecWebhookReceiversGithubSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectSpecWebhookReceiversGithubSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversGithubSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversGithubSecretRef(obj: ProjectSpecWebhookReceiversGithubSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The secret is expected to contain a `secret-token` key containing the
 * shared secret specified when registering the webhook in GitLab. For more
 * information about this token, please refer to the GitLab documentation:
 * https://docs.gitlab.com/user/project/integrations/webhooks/
 *
 * @schema ProjectSpecWebhookReceiversGitlabSecretRef
 */
export interface ProjectSpecWebhookReceiversGitlabSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectSpecWebhookReceiversGitlabSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversGitlabSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversGitlabSecretRef(obj: ProjectSpecWebhookReceiversGitlabSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose value
 * does NOT need to be shared directly with Quay when registering a
 * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
 * which implicitly serves as a shared secret. For more information about
 * Quay webhooks, please refer to the Quay documentation:
 * https://docs.quay.io/guides/notifications.html
 *
 * @schema ProjectSpecWebhookReceiversQuaySecretRef
 */
export interface ProjectSpecWebhookReceiversQuaySecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectSpecWebhookReceiversQuaySecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectSpecWebhookReceiversQuaySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectSpecWebhookReceiversQuaySecretRef(obj: ProjectSpecWebhookReceiversQuaySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ProjectConfig is a resource type that describes the configuration of a
Project.
 *
 * @schema ProjectConfig
 */
export class ProjectConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ProjectConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'ProjectConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ProjectConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ProjectConfigProps = {}): any {
    return {
      ...ProjectConfig.GVK,
      ...toJson_ProjectConfigProps(props),
    };
  }

  /**
   * Defines a "ProjectConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ProjectConfigProps = {}) {
    super(scope, id, {
      ...ProjectConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ProjectConfig.GVK,
      ...toJson_ProjectConfigProps(resolved),
    };
  }
}

/**
 * ProjectConfig is a resource type that describes the configuration of a
 * Project.
 *
 * @schema ProjectConfig
 */
export interface ProjectConfigProps {
  /**
   * @schema ProjectConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes the configuration of a Project.
   *
   * @schema ProjectConfig#spec
   */
  readonly spec?: ProjectConfigSpec;

}

/**
 * Converts an object of type 'ProjectConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigProps(obj: ProjectConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ProjectConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes the configuration of a Project.
 *
 * @schema ProjectConfigSpec
 */
export interface ProjectConfigSpec {
  /**
   * PromotionPolicies defines policies governing the promotion of Freight to
   * specific Stages within the Project.
   *
   * @schema ProjectConfigSpec#promotionPolicies
   */
  readonly promotionPolicies?: ProjectConfigSpecPromotionPolicies[];

  /**
   * WebhookReceivers describes Project-specific webhook receivers used for
   * processing events from various external platforms
   *
   * @schema ProjectConfigSpec#webhookReceivers
   */
  readonly webhookReceivers?: ProjectConfigSpecWebhookReceivers[];

}

/**
 * Converts an object of type 'ProjectConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpec(obj: ProjectConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'promotionPolicies': obj.promotionPolicies?.map(y => toJson_ProjectConfigSpecPromotionPolicies(y)),
    'webhookReceivers': obj.webhookReceivers?.map(y => toJson_ProjectConfigSpecWebhookReceivers(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionPolicy defines policies governing the promotion of Freight to a
 * specific Stage.
 *
 * @schema ProjectConfigSpecPromotionPolicies
 */
export interface ProjectConfigSpecPromotionPolicies {
  /**
   * AutoPromotionEnabled indicates whether new Freight can automatically be
   * promoted into the Stage referenced by the Stage field. Note: There are may
   * be other conditions also required for an auto-promotion to occur. This
   * field defaults to false, but is commonly set to true for Stages that
   * subscribe to Warehouses instead of other, upstream Stages. This allows
   * users to define Stages that are automatically updated as soon as new
   * artifacts are detected.
   *
   * @schema ProjectConfigSpecPromotionPolicies#autoPromotionEnabled
   */
  readonly autoPromotionEnabled?: boolean;

  /**
   * Stage is the name of the Stage to which this policy applies.
   *
   * Deprecated: Use StageSelector instead.
   *
   * @schema ProjectConfigSpecPromotionPolicies#stage
   */
  readonly stage?: string;

  /**
   * StageSelector is a selector that matches the Stage resource to which
   * this policy applies.
   *
   * @schema ProjectConfigSpecPromotionPolicies#stageSelector
   */
  readonly stageSelector?: ProjectConfigSpecPromotionPoliciesStageSelector;

}

/**
 * Converts an object of type 'ProjectConfigSpecPromotionPolicies' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecPromotionPolicies(obj: ProjectConfigSpecPromotionPolicies | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'autoPromotionEnabled': obj.autoPromotionEnabled,
    'stage': obj.stage,
    'stageSelector': toJson_ProjectConfigSpecPromotionPoliciesStageSelector(obj.stageSelector),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * WebhookReceiverConfig describes the configuration for a single webhook
 * receiver.
 *
 * @schema ProjectConfigSpecWebhookReceivers
 */
export interface ProjectConfigSpecWebhookReceivers {
  /**
   * Bitbucket contains the configuration for a webhook receiver that is
   * compatible with Bitbucket payloads.
   *
   * @schema ProjectConfigSpecWebhookReceivers#bitbucket
   */
  readonly bitbucket?: ProjectConfigSpecWebhookReceiversBitbucket;

  /**
   * DockerHub contains the configuration for a webhook receiver that is
   * compatible with DockerHub payloads.
   *
   * @schema ProjectConfigSpecWebhookReceivers#dockerhub
   */
  readonly dockerhub?: ProjectConfigSpecWebhookReceiversDockerhub;

  /**
   * GitHub contains the configuration for a webhook receiver that is compatible
   * with GitHub payloads.
   *
   * @schema ProjectConfigSpecWebhookReceivers#github
   */
  readonly github?: ProjectConfigSpecWebhookReceiversGithub;

  /**
   * GitLab contains the configuration for a webhook receiver that is compatible
   * with GitLab payloads.
   *
   * @schema ProjectConfigSpecWebhookReceivers#gitlab
   */
  readonly gitlab?: ProjectConfigSpecWebhookReceiversGitlab;

  /**
   * Name is the name of the webhook receiver.
   *
   * @schema ProjectConfigSpecWebhookReceivers#name
   */
  readonly name: string;

  /**
   * Quay contains the configuration for a webhook receiver that is compatible
   * with Quay payloads.
   *
   * @schema ProjectConfigSpecWebhookReceivers#quay
   */
  readonly quay?: ProjectConfigSpecWebhookReceiversQuay;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceivers' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceivers(obj: ProjectConfigSpecWebhookReceivers | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bitbucket': toJson_ProjectConfigSpecWebhookReceiversBitbucket(obj.bitbucket),
    'dockerhub': toJson_ProjectConfigSpecWebhookReceiversDockerhub(obj.dockerhub),
    'github': toJson_ProjectConfigSpecWebhookReceiversGithub(obj.github),
    'gitlab': toJson_ProjectConfigSpecWebhookReceiversGitlab(obj.gitlab),
    'name': obj.name,
    'quay': toJson_ProjectConfigSpecWebhookReceiversQuay(obj.quay),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * StageSelector is a selector that matches the Stage resource to which
 * this policy applies.
 *
 * @schema ProjectConfigSpecPromotionPoliciesStageSelector
 */
export interface ProjectConfigSpecPromotionPoliciesStageSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ProjectConfigSpecPromotionPoliciesStageSelector#matchExpressions
   */
  readonly matchExpressions?: ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels
   * map is equivalent to an element of matchExpressions, whose key field is "key", the
   * operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ProjectConfigSpecPromotionPoliciesStageSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

  /**
   * Name is the name of the resource to which this policy applies.
   *
   * It can be an exact name, a regex pattern (with prefix "regex:"), or a
   * glob pattern (with prefix "glob:").
   *
   * When both Name and LabelSelector are specified, the Name is ANDed with
   * the LabelSelector. I.e., the resource must match both the Name and
   * LabelSelector to be selected by this policy.
   *
   * NOTE: Using a specific exact name is the most secure option. Pattern
   * matching via regex or glob can be exploited by users with permissions to
   * match promotion policies that weren't intended to apply to their
   * resources. For example, a user could create a resource with a name
   * deliberately crafted to match the pattern, potentially bypassing intended
   * promotion controls.
   *
   * @schema ProjectConfigSpecPromotionPoliciesStageSelector#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectConfigSpecPromotionPoliciesStageSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecPromotionPoliciesStageSelector(obj: ProjectConfigSpecPromotionPoliciesStageSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Bitbucket contains the configuration for a webhook receiver that is
 * compatible with Bitbucket payloads.
 *
 * @schema ProjectConfigSpecWebhookReceiversBitbucket
 */
export interface ProjectConfigSpecWebhookReceiversBitbucket {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose
   * value is the shared secret used to authenticate the webhook requests sent
   * by Bitbucket. For more information please refer to the Bitbucket
   * documentation:
   * https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/
   *
   * @schema ProjectConfigSpecWebhookReceiversBitbucket#secretRef
   */
  readonly secretRef: ProjectConfigSpecWebhookReceiversBitbucketSecretRef;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversBitbucket' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversBitbucket(obj: ProjectConfigSpecWebhookReceiversBitbucket | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectConfigSpecWebhookReceiversBitbucketSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * DockerHub contains the configuration for a webhook receiver that is
 * compatible with DockerHub payloads.
 *
 * @schema ProjectConfigSpecWebhookReceiversDockerhub
 */
export interface ProjectConfigSpecWebhookReceiversDockerhub {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * The Secret's data map is expected to contain a `secret` key whose value
   * does NOT need to be shared directly with Docker Hub when registering a
   * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
   * which implicitly serves as a shared secret. For more information about
   * Docker Hub webhooks, please refer to the Docker documentation:
   * https://docs.docker.com/docker-hub/webhooks/
   *
   * @schema ProjectConfigSpecWebhookReceiversDockerhub#secretRef
   */
  readonly secretRef: ProjectConfigSpecWebhookReceiversDockerhubSecretRef;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversDockerhub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversDockerhub(obj: ProjectConfigSpecWebhookReceiversDockerhub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectConfigSpecWebhookReceiversDockerhubSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitHub contains the configuration for a webhook receiver that is compatible
 * with GitHub payloads.
 *
 * @schema ProjectConfigSpecWebhookReceiversGithub
 */
export interface ProjectConfigSpecWebhookReceiversGithub {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose value is
   * the shared secret used to authenticate the webhook requests sent by GitHub.
   * For more information please refer to GitHub documentation:
   * https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries
   *
   * @schema ProjectConfigSpecWebhookReceiversGithub#secretRef
   */
  readonly secretRef: ProjectConfigSpecWebhookReceiversGithubSecretRef;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversGithub' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversGithub(obj: ProjectConfigSpecWebhookReceiversGithub | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectConfigSpecWebhookReceiversGithubSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab contains the configuration for a webhook receiver that is compatible
 * with GitLab payloads.
 *
 * @schema ProjectConfigSpecWebhookReceiversGitlab
 */
export interface ProjectConfigSpecWebhookReceiversGitlab {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The secret is expected to contain a `secret-token` key containing the
   * shared secret specified when registering the webhook in GitLab. For more
   * information about this token, please refer to the GitLab documentation:
   * https://docs.gitlab.com/user/project/integrations/webhooks/
   *
   * @schema ProjectConfigSpecWebhookReceiversGitlab#secretRef
   */
  readonly secretRef: ProjectConfigSpecWebhookReceiversGitlabSecretRef;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversGitlab(obj: ProjectConfigSpecWebhookReceiversGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectConfigSpecWebhookReceiversGitlabSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Quay contains the configuration for a webhook receiver that is compatible
 * with Quay payloads.
 *
 * @schema ProjectConfigSpecWebhookReceiversQuay
 */
export interface ProjectConfigSpecWebhookReceiversQuay {
  /**
   * SecretRef contains a reference to a Secret. For Project-scoped webhook
   * receivers, the referenced Secret must be in the same namespace as the
   * ProjectConfig.
   *
   * For cluster-scoped webhook receivers, the referenced Secret must be in the
   * designated "cluster Secrets" namespace.
   *
   * The Secret's data map is expected to contain a `secret` key whose value
   * does NOT need to be shared directly with Quay when registering a
   * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
   * which implicitly serves as a shared secret. For more information about
   * Quay webhooks, please refer to the Quay documentation:
   * https://docs.quay.io/guides/notifications.html
   *
   * @schema ProjectConfigSpecWebhookReceiversQuay#secretRef
   */
  readonly secretRef: ProjectConfigSpecWebhookReceiversQuaySecretRef;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversQuay' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversQuay(obj: ProjectConfigSpecWebhookReceiversQuay | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ProjectConfigSpecWebhookReceiversQuaySecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that
 * relates the key and values.
 *
 * @schema ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions
 */
export interface ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values.
   * Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn,
   * the values array must be non-empty. If the operator is Exists or DoesNotExist,
   * the values array must be empty. This array is replaced during a strategic
   * merge patch.
   *
   * @schema ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions(obj: ProjectConfigSpecPromotionPoliciesStageSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose
 * value is the shared secret used to authenticate the webhook requests sent
 * by Bitbucket. For more information please refer to the Bitbucket
 * documentation:
 * https://support.atlassian.com/bitbucket-cloud/docs/manage-webhooks/
 *
 * @schema ProjectConfigSpecWebhookReceiversBitbucketSecretRef
 */
export interface ProjectConfigSpecWebhookReceiversBitbucketSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectConfigSpecWebhookReceiversBitbucketSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversBitbucketSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversBitbucketSecretRef(obj: ProjectConfigSpecWebhookReceiversBitbucketSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * The Secret's data map is expected to contain a `secret` key whose value
 * does NOT need to be shared directly with Docker Hub when registering a
 * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
 * which implicitly serves as a shared secret. For more information about
 * Docker Hub webhooks, please refer to the Docker documentation:
 * https://docs.docker.com/docker-hub/webhooks/
 *
 * @schema ProjectConfigSpecWebhookReceiversDockerhubSecretRef
 */
export interface ProjectConfigSpecWebhookReceiversDockerhubSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectConfigSpecWebhookReceiversDockerhubSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversDockerhubSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversDockerhubSecretRef(obj: ProjectConfigSpecWebhookReceiversDockerhubSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose value is
 * the shared secret used to authenticate the webhook requests sent by GitHub.
 * For more information please refer to GitHub documentation:
 * https://docs.github.com/en/webhooks/using-webhooks/validating-webhook-deliveries
 *
 * @schema ProjectConfigSpecWebhookReceiversGithubSecretRef
 */
export interface ProjectConfigSpecWebhookReceiversGithubSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectConfigSpecWebhookReceiversGithubSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversGithubSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversGithubSecretRef(obj: ProjectConfigSpecWebhookReceiversGithubSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The secret is expected to contain a `secret-token` key containing the
 * shared secret specified when registering the webhook in GitLab. For more
 * information about this token, please refer to the GitLab documentation:
 * https://docs.gitlab.com/user/project/integrations/webhooks/
 *
 * @schema ProjectConfigSpecWebhookReceiversGitlabSecretRef
 */
export interface ProjectConfigSpecWebhookReceiversGitlabSecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectConfigSpecWebhookReceiversGitlabSecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversGitlabSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversGitlabSecretRef(obj: ProjectConfigSpecWebhookReceiversGitlabSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef contains a reference to a Secret. For Project-scoped webhook
 * receivers, the referenced Secret must be in the same namespace as the
 * ProjectConfig.
 *
 * For cluster-scoped webhook receivers, the referenced Secret must be in the
 * designated "cluster Secrets" namespace.
 *
 * The Secret's data map is expected to contain a `secret` key whose value
 * does NOT need to be shared directly with Quay when registering a
 * webhook. It is used only by Kargo to create a complex, hard-to-guess URL,
 * which implicitly serves as a shared secret. For more information about
 * Quay webhooks, please refer to the Quay documentation:
 * https://docs.quay.io/guides/notifications.html
 *
 * @schema ProjectConfigSpecWebhookReceiversQuaySecretRef
 */
export interface ProjectConfigSpecWebhookReceiversQuaySecretRef {
  /**
   * Name of the referent.
   * This field is effectively required, but due to backwards compatibility is
   * allowed to be empty. Instances of this type with an empty value here are
   * almost certainly wrong.
   * More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
   *
   * @schema ProjectConfigSpecWebhookReceiversQuaySecretRef#name
   */
  readonly name?: string;

}

/**
 * Converts an object of type 'ProjectConfigSpecWebhookReceiversQuaySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ProjectConfigSpecWebhookReceiversQuaySecretRef(obj: ProjectConfigSpecWebhookReceiversQuaySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Promotion represents a request to transition a particular Stage into a
particular Freight.
 *
 * @schema Promotion
 */
export class Promotion extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Promotion"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'Promotion',
  }

  /**
   * Renders a Kubernetes manifest for "Promotion".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PromotionProps): any {
    return {
      ...Promotion.GVK,
      ...toJson_PromotionProps(props),
    };
  }

  /**
   * Defines a "Promotion" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PromotionProps) {
    super(scope, id, {
      ...Promotion.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Promotion.GVK,
      ...toJson_PromotionProps(resolved),
    };
  }
}

/**
 * Promotion represents a request to transition a particular Stage into a
 * particular Freight.
 *
 * @schema Promotion
 */
export interface PromotionProps {
  /**
   * @schema Promotion#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes the desired transition of a specific Stage into a specific
   * Freight.
   *
   * @schema Promotion#spec
   */
  readonly spec: PromotionSpec;

}

/**
 * Converts an object of type 'PromotionProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionProps(obj: PromotionProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PromotionSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes the desired transition of a specific Stage into a specific
 * Freight.
 *
 * @schema PromotionSpec
 */
export interface PromotionSpec {
  /**
   * Freight specifies the piece of Freight to be promoted into the Stage
   * referenced by the Stage field.
   *
   * @schema PromotionSpec#freight
   */
  readonly freight: string;

  /**
   * Stage specifies the name of the Stage to which this Promotion
   * applies. The Stage referenced by this field MUST be in the same
   * namespace as the Promotion.
   *
   * @schema PromotionSpec#stage
   */
  readonly stage: string;

  /**
   * Steps specifies the directives to be executed as part of this Promotion.
   * The order in which the directives are executed is the order in which they
   * are listed in this field.
   *
   * @schema PromotionSpec#steps
   */
  readonly steps: PromotionSpecSteps[];

  /**
   * Vars is a list of variables that can be referenced by expressions in
   * promotion steps.
   *
   * @schema PromotionSpec#vars
   */
  readonly vars?: PromotionSpecVars[];

}

/**
 * Converts an object of type 'PromotionSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionSpec(obj: PromotionSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'freight': obj.freight,
    'stage': obj.stage,
    'steps': obj.steps?.map(y => toJson_PromotionSpecSteps(y)),
    'vars': obj.vars?.map(y => toJson_PromotionSpecVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionStep describes a directive to be executed as part of a Promotion.
 *
 * @schema PromotionSpecSteps
 */
export interface PromotionSpecSteps {
  /**
   * As is the alias this step can be referred to as.
   *
   * @schema PromotionSpecSteps#as
   */
  readonly as?: string;

  /**
   * Config is opaque configuration for the PromotionStep that is understood
   * only by each PromotionStep's implementation. It is legal to utilize
   * expressions in defining values at any level of this block.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema PromotionSpecSteps#config
   */
  readonly config?: any;

  /**
   * ContinueOnError is a boolean value that, if set to true, will cause the
   * Promotion to continue executing the next step even if this step fails. It
   * also will not permit this failure to impact the overall status of the
   * Promotion.
   *
   * @schema PromotionSpecSteps#continueOnError
   */
  readonly continueOnError?: boolean;

  /**
   * If is an optional expression that, if present, must evaluate to a boolean
   * value. If the expression evaluates to false, the step will be skipped.
   * If the expression does not evaluate to a boolean value, the step will be
   * considered to have failed.
   *
   * @schema PromotionSpecSteps#if
   */
  readonly if?: string;

  /**
   * Retry is the retry policy for this step.
   *
   * @schema PromotionSpecSteps#retry
   */
  readonly retry?: PromotionSpecStepsRetry;

  /**
   * Task is a reference to a PromotionTask that should be inflated into a
   * Promotion when it is built from a PromotionTemplate.
   *
   * @schema PromotionSpecSteps#task
   */
  readonly task?: PromotionSpecStepsTask;

  /**
   * Uses identifies a runner that can execute this step.
   *
   * @schema PromotionSpecSteps#uses
   */
  readonly uses?: string;

  /**
   * Vars is a list of variables that can be referenced by expressions in
   * the step's Config. The values override the values specified in the
   * PromotionSpec.
   *
   * @schema PromotionSpecSteps#vars
   */
  readonly vars?: PromotionSpecStepsVars[];

}

/**
 * Converts an object of type 'PromotionSpecSteps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionSpecSteps(obj: PromotionSpecSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as': obj.as,
    'config': obj.config,
    'continueOnError': obj.continueOnError,
    'if': obj.if,
    'retry': toJson_PromotionSpecStepsRetry(obj.retry),
    'task': toJson_PromotionSpecStepsTask(obj.task),
    'uses': obj.uses,
    'vars': obj.vars?.map(y => toJson_PromotionSpecStepsVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema PromotionSpecVars
 */
export interface PromotionSpecVars {
  /**
   * Name is the name of the variable.
   *
   * @schema PromotionSpecVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema PromotionSpecVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PromotionSpecVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionSpecVars(obj: PromotionSpecVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry is the retry policy for this step.
 *
 * @schema PromotionSpecStepsRetry
 */
export interface PromotionSpecStepsRetry {
  /**
   * ErrorThreshold is the number of consecutive times the step must fail (for
   * any reason) before retries are abandoned and the entire Promotion is marked
   * as failed.
   *
   * If this field is set to 0, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also 0), the effective
   * default will be the system-wide default of 1.
   *
   * A value of 1 will cause the Promotion to be marked as failed after just
   * a single failure; i.e. no retries will be attempted.
   *
   * There is no option to specify an infinite number of retries using a value
   * such as -1.
   *
   * In a future release, Kargo is likely to become capable of distinguishing
   * between recoverable and non-recoverable step failures. At that time, it is
   * planned that unrecoverable failures will not be subject to this threshold
   * and will immediately cause the Promotion to be marked as failed without
   * further condition.
   *
   * @schema PromotionSpecStepsRetry#errorThreshold
   */
  readonly errorThreshold?: number;

  /**
   * Timeout is the soft maximum interval in which a step that returns a Running
   * status (which typically indicates it's waiting for something to happen)
   * may be retried.
   *
   * The maximum is a soft one because the check for whether the interval has
   * elapsed occurs AFTER the step has run. This effectively means a step may
   * run ONCE beyond the close of the interval.
   *
   * If this field is set to nil, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also nil), the effective
   * default will be the system-wide default of 0.
   *
   * A value of 0 will cause the step to be retried indefinitely unless the
   * ErrorThreshold is reached.
   *
   * @schema PromotionSpecStepsRetry#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'PromotionSpecStepsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionSpecStepsRetry(obj: PromotionSpecStepsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorThreshold': obj.errorThreshold,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Task is a reference to a PromotionTask that should be inflated into a
 * Promotion when it is built from a PromotionTemplate.
 *
 * @schema PromotionSpecStepsTask
 */
export interface PromotionSpecStepsTask {
  /**
   * Kind is the type of the PromotionTask. Can be either PromotionTask or
   * ClusterPromotionTask, default is PromotionTask.
   *
   * @schema PromotionSpecStepsTask#kind
   */
  readonly kind?: PromotionSpecStepsTaskKind;

  /**
   * Name is the name of the (Cluster)PromotionTask.
   *
   * @schema PromotionSpecStepsTask#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PromotionSpecStepsTask' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionSpecStepsTask(obj: PromotionSpecStepsTask | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema PromotionSpecStepsVars
 */
export interface PromotionSpecStepsVars {
  /**
   * Name is the name of the variable.
   *
   * @schema PromotionSpecStepsVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema PromotionSpecStepsVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PromotionSpecStepsVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionSpecStepsVars(obj: PromotionSpecStepsVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the type of the PromotionTask. Can be either PromotionTask or
 * ClusterPromotionTask, default is PromotionTask.
 *
 * @schema PromotionSpecStepsTaskKind
 */
export enum PromotionSpecStepsTaskKind {
  /** PromotionTask */
  PROMOTION_TASK = "PromotionTask",
  /** ClusterPromotionTask */
  CLUSTER_PROMOTION_TASK = "ClusterPromotionTask",
}


/**
 *
 *
 * @schema PromotionTask
 */
export class PromotionTask extends ApiObject {
  /**
   * Returns the apiVersion and kind for "PromotionTask"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'PromotionTask',
  }

  /**
   * Renders a Kubernetes manifest for "PromotionTask".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: PromotionTaskProps): any {
    return {
      ...PromotionTask.GVK,
      ...toJson_PromotionTaskProps(props),
    };
  }

  /**
   * Defines a "PromotionTask" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: PromotionTaskProps) {
    super(scope, id, {
      ...PromotionTask.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...PromotionTask.GVK,
      ...toJson_PromotionTaskProps(resolved),
    };
  }
}

/**
 * @schema PromotionTask
 */
export interface PromotionTaskProps {
  /**
   * @schema PromotionTask#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes the composition of a PromotionTask, including the
   * variables available to the task and the steps.
   *
   * @schema PromotionTask#spec
   */
  readonly spec: PromotionTaskSpec;

}

/**
 * Converts an object of type 'PromotionTaskProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskProps(obj: PromotionTaskProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_PromotionTaskSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes the composition of a PromotionTask, including the
 * variables available to the task and the steps.
 *
 * @schema PromotionTaskSpec
 */
export interface PromotionTaskSpec {
  /**
   * Steps specifies the directives to be executed as part of this
   * PromotionTask. The steps as defined here are inflated into a
   * Promotion when it is built from a PromotionTemplate.
   *
   * @schema PromotionTaskSpec#steps
   */
  readonly steps: PromotionTaskSpecSteps[];

  /**
   * Vars specifies the variables available to the PromotionTask. The
   * values of these variables are the default values that can be
   * overridden by the step referencing the task.
   *
   * @schema PromotionTaskSpec#vars
   */
  readonly vars?: PromotionTaskSpecVars[];

}

/**
 * Converts an object of type 'PromotionTaskSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskSpec(obj: PromotionTaskSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'steps': obj.steps?.map(y => toJson_PromotionTaskSpecSteps(y)),
    'vars': obj.vars?.map(y => toJson_PromotionTaskSpecVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionStep describes a directive to be executed as part of a Promotion.
 *
 * @schema PromotionTaskSpecSteps
 */
export interface PromotionTaskSpecSteps {
  /**
   * As is the alias this step can be referred to as.
   *
   * @schema PromotionTaskSpecSteps#as
   */
  readonly as?: string;

  /**
   * Config is opaque configuration for the PromotionStep that is understood
   * only by each PromotionStep's implementation. It is legal to utilize
   * expressions in defining values at any level of this block.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema PromotionTaskSpecSteps#config
   */
  readonly config?: any;

  /**
   * ContinueOnError is a boolean value that, if set to true, will cause the
   * Promotion to continue executing the next step even if this step fails. It
   * also will not permit this failure to impact the overall status of the
   * Promotion.
   *
   * @schema PromotionTaskSpecSteps#continueOnError
   */
  readonly continueOnError?: boolean;

  /**
   * If is an optional expression that, if present, must evaluate to a boolean
   * value. If the expression evaluates to false, the step will be skipped.
   * If the expression does not evaluate to a boolean value, the step will be
   * considered to have failed.
   *
   * @schema PromotionTaskSpecSteps#if
   */
  readonly if?: string;

  /**
   * Retry is the retry policy for this step.
   *
   * @schema PromotionTaskSpecSteps#retry
   */
  readonly retry?: PromotionTaskSpecStepsRetry;

  /**
   * Task is a reference to a PromotionTask that should be inflated into a
   * Promotion when it is built from a PromotionTemplate.
   *
   * @schema PromotionTaskSpecSteps#task
   */
  readonly task?: PromotionTaskSpecStepsTask;

  /**
   * Uses identifies a runner that can execute this step.
   *
   * @schema PromotionTaskSpecSteps#uses
   */
  readonly uses?: string;

  /**
   * Vars is a list of variables that can be referenced by expressions in
   * the step's Config. The values override the values specified in the
   * PromotionSpec.
   *
   * @schema PromotionTaskSpecSteps#vars
   */
  readonly vars?: PromotionTaskSpecStepsVars[];

}

/**
 * Converts an object of type 'PromotionTaskSpecSteps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskSpecSteps(obj: PromotionTaskSpecSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as': obj.as,
    'config': obj.config,
    'continueOnError': obj.continueOnError,
    'if': obj.if,
    'retry': toJson_PromotionTaskSpecStepsRetry(obj.retry),
    'task': toJson_PromotionTaskSpecStepsTask(obj.task),
    'uses': obj.uses,
    'vars': obj.vars?.map(y => toJson_PromotionTaskSpecStepsVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema PromotionTaskSpecVars
 */
export interface PromotionTaskSpecVars {
  /**
   * Name is the name of the variable.
   *
   * @schema PromotionTaskSpecVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema PromotionTaskSpecVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PromotionTaskSpecVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskSpecVars(obj: PromotionTaskSpecVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Retry is the retry policy for this step.
 *
 * @schema PromotionTaskSpecStepsRetry
 */
export interface PromotionTaskSpecStepsRetry {
  /**
   * ErrorThreshold is the number of consecutive times the step must fail (for
   * any reason) before retries are abandoned and the entire Promotion is marked
   * as failed.
   *
   * If this field is set to 0, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also 0), the effective
   * default will be the system-wide default of 1.
   *
   * A value of 1 will cause the Promotion to be marked as failed after just
   * a single failure; i.e. no retries will be attempted.
   *
   * There is no option to specify an infinite number of retries using a value
   * such as -1.
   *
   * In a future release, Kargo is likely to become capable of distinguishing
   * between recoverable and non-recoverable step failures. At that time, it is
   * planned that unrecoverable failures will not be subject to this threshold
   * and will immediately cause the Promotion to be marked as failed without
   * further condition.
   *
   * @schema PromotionTaskSpecStepsRetry#errorThreshold
   */
  readonly errorThreshold?: number;

  /**
   * Timeout is the soft maximum interval in which a step that returns a Running
   * status (which typically indicates it's waiting for something to happen)
   * may be retried.
   *
   * The maximum is a soft one because the check for whether the interval has
   * elapsed occurs AFTER the step has run. This effectively means a step may
   * run ONCE beyond the close of the interval.
   *
   * If this field is set to nil, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also nil), the effective
   * default will be the system-wide default of 0.
   *
   * A value of 0 will cause the step to be retried indefinitely unless the
   * ErrorThreshold is reached.
   *
   * @schema PromotionTaskSpecStepsRetry#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'PromotionTaskSpecStepsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskSpecStepsRetry(obj: PromotionTaskSpecStepsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorThreshold': obj.errorThreshold,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Task is a reference to a PromotionTask that should be inflated into a
 * Promotion when it is built from a PromotionTemplate.
 *
 * @schema PromotionTaskSpecStepsTask
 */
export interface PromotionTaskSpecStepsTask {
  /**
   * Kind is the type of the PromotionTask. Can be either PromotionTask or
   * ClusterPromotionTask, default is PromotionTask.
   *
   * @schema PromotionTaskSpecStepsTask#kind
   */
  readonly kind?: PromotionTaskSpecStepsTaskKind;

  /**
   * Name is the name of the (Cluster)PromotionTask.
   *
   * @schema PromotionTaskSpecStepsTask#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'PromotionTaskSpecStepsTask' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskSpecStepsTask(obj: PromotionTaskSpecStepsTask | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema PromotionTaskSpecStepsVars
 */
export interface PromotionTaskSpecStepsVars {
  /**
   * Name is the name of the variable.
   *
   * @schema PromotionTaskSpecStepsVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema PromotionTaskSpecStepsVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'PromotionTaskSpecStepsVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_PromotionTaskSpecStepsVars(obj: PromotionTaskSpecStepsVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the type of the PromotionTask. Can be either PromotionTask or
 * ClusterPromotionTask, default is PromotionTask.
 *
 * @schema PromotionTaskSpecStepsTaskKind
 */
export enum PromotionTaskSpecStepsTaskKind {
  /** PromotionTask */
  PROMOTION_TASK = "PromotionTask",
  /** ClusterPromotionTask */
  CLUSTER_PROMOTION_TASK = "ClusterPromotionTask",
}


/**
 * Stage is the Kargo API's main type.
 *
 * @schema Stage
 */
export class Stage extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Stage"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'Stage',
  }

  /**
   * Renders a Kubernetes manifest for "Stage".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: StageProps): any {
    return {
      ...Stage.GVK,
      ...toJson_StageProps(props),
    };
  }

  /**
   * Defines a "Stage" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: StageProps) {
    super(scope, id, {
      ...Stage.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Stage.GVK,
      ...toJson_StageProps(resolved),
    };
  }
}

/**
 * Stage is the Kargo API's main type.
 *
 * @schema Stage
 */
export interface StageProps {
  /**
   * @schema Stage#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes sources of Freight used by the Stage and how to incorporate
   * Freight into the Stage.
   *
   * @schema Stage#spec
   */
  readonly spec: StageSpec;

}

/**
 * Converts an object of type 'StageProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageProps(obj: StageProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_StageSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes sources of Freight used by the Stage and how to incorporate
 * Freight into the Stage.
 *
 * @schema StageSpec
 */
export interface StageSpec {
  /**
   * PromotionTemplate describes how to incorporate Freight into the Stage
   * using a Promotion.
   *
   * @schema StageSpec#promotionTemplate
   */
  readonly promotionTemplate?: StageSpecPromotionTemplate;

  /**
   * RequestedFreight expresses the Stage's need for certain pieces of Freight,
   * each having originated from a particular Warehouse. This list must be
   * non-empty. In the common case, a Stage will request Freight having
   * originated from just one specific Warehouse. In advanced cases, requesting
   * Freight from multiple Warehouses provides a method of advancing new
   * artifacts of different types through parallel pipelines at different
   * speeds. This can be useful, for instance, if a Stage is home to multiple
   * microservices that are independently versioned.
   *
   * @schema StageSpec#requestedFreight
   */
  readonly requestedFreight: StageSpecRequestedFreight[];

  /**
   * Shard is the name of the shard that this Stage belongs to. This is an
   * optional field. If not specified, the Stage will belong to the default
   * shard. A defaulting webhook will sync the value of the
   * kargo.akuity.io/shard label with the value of this field. When this field
   * is empty, the webhook will ensure that label is absent.
   *
   * @schema StageSpec#shard
   */
  readonly shard?: string;

  /**
   * Vars is a list of variables that can be referenced anywhere in the
   * StageSpec that supports expressions. For example, the PromotionTemplate
   * and arguments of the Verification.
   *
   * @schema StageSpec#vars
   */
  readonly vars?: StageSpecVars[];

  /**
   * Verification describes how to verify a Stage's current Freight is fit for
   * promotion downstream.
   *
   * @schema StageSpec#verification
   */
  readonly verification?: StageSpecVerification;

}

/**
 * Converts an object of type 'StageSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpec(obj: StageSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'promotionTemplate': toJson_StageSpecPromotionTemplate(obj.promotionTemplate),
    'requestedFreight': obj.requestedFreight?.map(y => toJson_StageSpecRequestedFreight(y)),
    'shard': obj.shard,
    'vars': obj.vars?.map(y => toJson_StageSpecVars(y)),
    'verification': toJson_StageSpecVerification(obj.verification),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionTemplate describes how to incorporate Freight into the Stage
 * using a Promotion.
 *
 * @schema StageSpecPromotionTemplate
 */
export interface StageSpecPromotionTemplate {
  /**
   * PromotionTemplateSpec describes the (partial) specification of a Promotion
   * for a Stage. This is a template that can be used to create a Promotion for a
   * Stage.
   *
   * @schema StageSpecPromotionTemplate#spec
   */
  readonly spec: StageSpecPromotionTemplateSpec;

}

/**
 * Converts an object of type 'StageSpecPromotionTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplate(obj: StageSpecPromotionTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'spec': toJson_StageSpecPromotionTemplateSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FreightRequest expresses a Stage's need for Freight having originated from a
 * particular Warehouse.
 *
 * @schema StageSpecRequestedFreight
 */
export interface StageSpecRequestedFreight {
  /**
   * Origin specifies from where the requested Freight must have originated.
   * This is a required field.
   *
   * @schema StageSpecRequestedFreight#origin
   */
  readonly origin: StageSpecRequestedFreightOrigin;

  /**
   * Sources describes where the requested Freight may be obtained from. This is
   * a required field.
   *
   * @schema StageSpecRequestedFreight#sources
   */
  readonly sources: StageSpecRequestedFreightSources;

}

/**
 * Converts an object of type 'StageSpecRequestedFreight' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecRequestedFreight(obj: StageSpecRequestedFreight | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'origin': toJson_StageSpecRequestedFreightOrigin(obj.origin),
    'sources': toJson_StageSpecRequestedFreightSources(obj.sources),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema StageSpecVars
 */
export interface StageSpecVars {
  /**
   * Name is the name of the variable.
   *
   * @schema StageSpecVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema StageSpecVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'StageSpecVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecVars(obj: StageSpecVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Verification describes how to verify a Stage's current Freight is fit for
 * promotion downstream.
 *
 * @schema StageSpecVerification
 */
export interface StageSpecVerification {
  /**
   * AnalysisRunMetadata contains optional metadata that should be applied to
   * all AnalysisRuns.
   *
   * @schema StageSpecVerification#analysisRunMetadata
   */
  readonly analysisRunMetadata?: StageSpecVerificationAnalysisRunMetadata;

  /**
   * AnalysisTemplates is a list of AnalysisTemplates from which AnalysisRuns
   * should be created to verify a Stage's current Freight is fit to be promoted
   * downstream.
   *
   * @schema StageSpecVerification#analysisTemplates
   */
  readonly analysisTemplates?: StageSpecVerificationAnalysisTemplates[];

  /**
   * Args lists arguments that should be added to all AnalysisRuns.
   *
   * @schema StageSpecVerification#args
   */
  readonly args?: StageSpecVerificationArgs[];

}

/**
 * Converts an object of type 'StageSpecVerification' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecVerification(obj: StageSpecVerification | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'analysisRunMetadata': toJson_StageSpecVerificationAnalysisRunMetadata(obj.analysisRunMetadata),
    'analysisTemplates': obj.analysisTemplates?.map(y => toJson_StageSpecVerificationAnalysisTemplates(y)),
    'args': obj.args?.map(y => toJson_StageSpecVerificationArgs(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionTemplateSpec describes the (partial) specification of a Promotion
 * for a Stage. This is a template that can be used to create a Promotion for a
 * Stage.
 *
 * @schema StageSpecPromotionTemplateSpec
 */
export interface StageSpecPromotionTemplateSpec {
  /**
   * Steps specifies the directives to be executed as part of a Promotion.
   * The order in which the directives are executed is the order in which they
   * are listed in this field.
   *
   * @schema StageSpecPromotionTemplateSpec#steps
   */
  readonly steps?: StageSpecPromotionTemplateSpecSteps[];

  /**
   * Vars is a list of variables that can be referenced by expressions in
   * promotion steps.
   *
   * @schema StageSpecPromotionTemplateSpec#vars
   */
  readonly vars?: StageSpecPromotionTemplateSpecVars[];

}

/**
 * Converts an object of type 'StageSpecPromotionTemplateSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplateSpec(obj: StageSpecPromotionTemplateSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'steps': obj.steps?.map(y => toJson_StageSpecPromotionTemplateSpecSteps(y)),
    'vars': obj.vars?.map(y => toJson_StageSpecPromotionTemplateSpecVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Origin specifies from where the requested Freight must have originated.
 * This is a required field.
 *
 * @schema StageSpecRequestedFreightOrigin
 */
export interface StageSpecRequestedFreightOrigin {
  /**
   * Kind is the kind of resource from which Freight may have originated. At
   * present, this can only be "Warehouse".
   *
   * @schema StageSpecRequestedFreightOrigin#kind
   */
  readonly kind: StageSpecRequestedFreightOriginKind;

  /**
   * Name is the name of the resource of the kind indicated by the Kind field
   * from which Freight may originate.
   *
   * @schema StageSpecRequestedFreightOrigin#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecRequestedFreightOrigin' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecRequestedFreightOrigin(obj: StageSpecRequestedFreightOrigin | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Sources describes where the requested Freight may be obtained from. This is
 * a required field.
 *
 * @schema StageSpecRequestedFreightSources
 */
export interface StageSpecRequestedFreightSources {
  /**
   * AvailabilityStrategy specifies the semantics for how requested Freight is
   * made available to the Stage. This field is optional. When left unspecified,
   * the field is implicitly treated as if its value were "OneOf".
   *
   * Accepted Values:
   *
   * - "All": Freight must be be verified and, if applicable, soaked in all
   * upstream Stages to be considered available for promotion.
   * - "OneOf": Freight must be verified and, if applicable, soaked in at least
   * one upstream Stage to be considered available for promotion.
   * - "": Treated the same as "OneOf".
   *
   * @schema StageSpecRequestedFreightSources#availabilityStrategy
   */
  readonly availabilityStrategy?: StageSpecRequestedFreightSourcesAvailabilityStrategy;

  /**
   * Direct indicates the requested Freight may be obtained directly from the
   * Warehouse from which it originated. If this field's value is false, then
   * the value of the Stages field must be non-empty. i.e. Between the two
   * fields, at least one source must be specified.
   *
   * @schema StageSpecRequestedFreightSources#direct
   */
  readonly direct?: boolean;

  /**
   * RequiredSoakTime specifies a minimum duration for which the requested
   * Freight must have continuously occupied ("soaked in") in an upstream Stage
   * before becoming available for promotion to this Stage. This is an optional
   * field. If nil or zero, no soak time is required. Any soak time requirement
   * is in ADDITION to the requirement that Freight be verified in an upstream
   * Stage to become available for promotion to this Stage, although a manual
   * approval for promotion to this Stage will supersede any soak time
   * requirement.
   *
   * @schema StageSpecRequestedFreightSources#requiredSoakTime
   */
  readonly requiredSoakTime?: string;

  /**
   * Stages identifies other "upstream" Stages as potential sources of the
   * requested Freight. If this field's value is empty, then the value of the
   * Direct field must be true. i.e. Between the two fields, at least on source
   * must be specified.
   *
   * @schema StageSpecRequestedFreightSources#stages
   */
  readonly stages?: string[];

}

/**
 * Converts an object of type 'StageSpecRequestedFreightSources' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecRequestedFreightSources(obj: StageSpecRequestedFreightSources | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'availabilityStrategy': obj.availabilityStrategy,
    'direct': obj.direct,
    'requiredSoakTime': obj.requiredSoakTime,
    'stages': obj.stages?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AnalysisRunMetadata contains optional metadata that should be applied to
 * all AnalysisRuns.
 *
 * @schema StageSpecVerificationAnalysisRunMetadata
 */
export interface StageSpecVerificationAnalysisRunMetadata {
  /**
   * Additional annotations to apply to an AnalysisRun.
   *
   * @schema StageSpecVerificationAnalysisRunMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * Additional labels to apply to an AnalysisRun.
   *
   * @schema StageSpecVerificationAnalysisRunMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'StageSpecVerificationAnalysisRunMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecVerificationAnalysisRunMetadata(obj: StageSpecVerificationAnalysisRunMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AnalysisTemplateReference is a reference to an AnalysisTemplate.
 *
 * @schema StageSpecVerificationAnalysisTemplates
 */
export interface StageSpecVerificationAnalysisTemplates {
  /**
   * Kind is the type of the AnalysisTemplate. Can be either AnalysisTemplate or
   * ClusterAnalysisTemplate, default is AnalysisTemplate.
   *
   * @schema StageSpecVerificationAnalysisTemplates#kind
   */
  readonly kind?: StageSpecVerificationAnalysisTemplatesKind;

  /**
   * Name is the name of the AnalysisTemplate in the same project/namespace as
   * the Stage.
   *
   * @schema StageSpecVerificationAnalysisTemplates#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecVerificationAnalysisTemplates' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecVerificationAnalysisTemplates(obj: StageSpecVerificationAnalysisTemplates | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AnalysisRunArgument represents an argument to be added to an AnalysisRun.
 *
 * @schema StageSpecVerificationArgs
 */
export interface StageSpecVerificationArgs {
  /**
   * Name is the name of the argument.
   *
   * @schema StageSpecVerificationArgs#name
   */
  readonly name: string;

  /**
   * Value is the value of the argument.
   *
   * @schema StageSpecVerificationArgs#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'StageSpecVerificationArgs' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecVerificationArgs(obj: StageSpecVerificationArgs | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PromotionStep describes a directive to be executed as part of a Promotion.
 *
 * @schema StageSpecPromotionTemplateSpecSteps
 */
export interface StageSpecPromotionTemplateSpecSteps {
  /**
   * As is the alias this step can be referred to as.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#as
   */
  readonly as?: string;

  /**
   * Config is opaque configuration for the PromotionStep that is understood
   * only by each PromotionStep's implementation. It is legal to utilize
   * expressions in defining values at any level of this block.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#config
   */
  readonly config?: any;

  /**
   * ContinueOnError is a boolean value that, if set to true, will cause the
   * Promotion to continue executing the next step even if this step fails. It
   * also will not permit this failure to impact the overall status of the
   * Promotion.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#continueOnError
   */
  readonly continueOnError?: boolean;

  /**
   * If is an optional expression that, if present, must evaluate to a boolean
   * value. If the expression evaluates to false, the step will be skipped.
   * If the expression does not evaluate to a boolean value, the step will be
   * considered to have failed.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#if
   */
  readonly if?: string;

  /**
   * Retry is the retry policy for this step.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#retry
   */
  readonly retry?: StageSpecPromotionTemplateSpecStepsRetry;

  /**
   * Task is a reference to a PromotionTask that should be inflated into a
   * Promotion when it is built from a PromotionTemplate.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#task
   */
  readonly task?: StageSpecPromotionTemplateSpecStepsTask;

  /**
   * Uses identifies a runner that can execute this step.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#uses
   */
  readonly uses?: string;

  /**
   * Vars is a list of variables that can be referenced by expressions in
   * the step's Config. The values override the values specified in the
   * PromotionSpec.
   *
   * @schema StageSpecPromotionTemplateSpecSteps#vars
   */
  readonly vars?: StageSpecPromotionTemplateSpecStepsVars[];

}

/**
 * Converts an object of type 'StageSpecPromotionTemplateSpecSteps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplateSpecSteps(obj: StageSpecPromotionTemplateSpecSteps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'as': obj.as,
    'config': obj.config,
    'continueOnError': obj.continueOnError,
    'if': obj.if,
    'retry': toJson_StageSpecPromotionTemplateSpecStepsRetry(obj.retry),
    'task': toJson_StageSpecPromotionTemplateSpecStepsTask(obj.task),
    'uses': obj.uses,
    'vars': obj.vars?.map(y => toJson_StageSpecPromotionTemplateSpecStepsVars(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema StageSpecPromotionTemplateSpecVars
 */
export interface StageSpecPromotionTemplateSpecVars {
  /**
   * Name is the name of the variable.
   *
   * @schema StageSpecPromotionTemplateSpecVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema StageSpecPromotionTemplateSpecVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'StageSpecPromotionTemplateSpecVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplateSpecVars(obj: StageSpecPromotionTemplateSpecVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the kind of resource from which Freight may have originated. At
 * present, this can only be "Warehouse".
 *
 * @schema StageSpecRequestedFreightOriginKind
 */
export enum StageSpecRequestedFreightOriginKind {
  /** Warehouse */
  WAREHOUSE = "Warehouse",
}

/**
 * AvailabilityStrategy specifies the semantics for how requested Freight is
 * made available to the Stage. This field is optional. When left unspecified,
 * the field is implicitly treated as if its value were "OneOf".
 *
 * Accepted Values:
 *
 * - "All": Freight must be be verified and, if applicable, soaked in all
 * upstream Stages to be considered available for promotion.
 * - "OneOf": Freight must be verified and, if applicable, soaked in at least
 * one upstream Stage to be considered available for promotion.
 * - "": Treated the same as "OneOf".
 *
 * @schema StageSpecRequestedFreightSourcesAvailabilityStrategy
 */
export enum StageSpecRequestedFreightSourcesAvailabilityStrategy {
  /** All */
  ALL = "All",
  /** OneOf */
  ONE_OF = "OneOf",
}

/**
 * Kind is the type of the AnalysisTemplate. Can be either AnalysisTemplate or
 * ClusterAnalysisTemplate, default is AnalysisTemplate.
 *
 * @schema StageSpecVerificationAnalysisTemplatesKind
 */
export enum StageSpecVerificationAnalysisTemplatesKind {
  /** AnalysisTemplate */
  ANALYSIS_TEMPLATE = "AnalysisTemplate",
  /** ClusterAnalysisTemplate */
  CLUSTER_ANALYSIS_TEMPLATE = "ClusterAnalysisTemplate",
}

/**
 * Retry is the retry policy for this step.
 *
 * @schema StageSpecPromotionTemplateSpecStepsRetry
 */
export interface StageSpecPromotionTemplateSpecStepsRetry {
  /**
   * ErrorThreshold is the number of consecutive times the step must fail (for
   * any reason) before retries are abandoned and the entire Promotion is marked
   * as failed.
   *
   * If this field is set to 0, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also 0), the effective
   * default will be the system-wide default of 1.
   *
   * A value of 1 will cause the Promotion to be marked as failed after just
   * a single failure; i.e. no retries will be attempted.
   *
   * There is no option to specify an infinite number of retries using a value
   * such as -1.
   *
   * In a future release, Kargo is likely to become capable of distinguishing
   * between recoverable and non-recoverable step failures. At that time, it is
   * planned that unrecoverable failures will not be subject to this threshold
   * and will immediately cause the Promotion to be marked as failed without
   * further condition.
   *
   * @schema StageSpecPromotionTemplateSpecStepsRetry#errorThreshold
   */
  readonly errorThreshold?: number;

  /**
   * Timeout is the soft maximum interval in which a step that returns a Running
   * status (which typically indicates it's waiting for something to happen)
   * may be retried.
   *
   * The maximum is a soft one because the check for whether the interval has
   * elapsed occurs AFTER the step has run. This effectively means a step may
   * run ONCE beyond the close of the interval.
   *
   * If this field is set to nil, the effective default will be a step-specific
   * one. If no step-specific default exists (i.e. is also nil), the effective
   * default will be the system-wide default of 0.
   *
   * A value of 0 will cause the step to be retried indefinitely unless the
   * ErrorThreshold is reached.
   *
   * @schema StageSpecPromotionTemplateSpecStepsRetry#timeout
   */
  readonly timeout?: string;

}

/**
 * Converts an object of type 'StageSpecPromotionTemplateSpecStepsRetry' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplateSpecStepsRetry(obj: StageSpecPromotionTemplateSpecStepsRetry | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'errorThreshold': obj.errorThreshold,
    'timeout': obj.timeout,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Task is a reference to a PromotionTask that should be inflated into a
 * Promotion when it is built from a PromotionTemplate.
 *
 * @schema StageSpecPromotionTemplateSpecStepsTask
 */
export interface StageSpecPromotionTemplateSpecStepsTask {
  /**
   * Kind is the type of the PromotionTask. Can be either PromotionTask or
   * ClusterPromotionTask, default is PromotionTask.
   *
   * @schema StageSpecPromotionTemplateSpecStepsTask#kind
   */
  readonly kind?: StageSpecPromotionTemplateSpecStepsTaskKind;

  /**
   * Name is the name of the (Cluster)PromotionTask.
   *
   * @schema StageSpecPromotionTemplateSpecStepsTask#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'StageSpecPromotionTemplateSpecStepsTask' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplateSpecStepsTask(obj: StageSpecPromotionTemplateSpecStepsTask | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExpressionVariable describes a single variable that may be referenced by
 * expressions in the context of a ClusterPromotionTask, PromotionTask,
 * Promotion, AnalysisRun arguments, or other objects that support expressions.
 *
 * It is used to pass information to the expression evaluation engine, and to
 * allow for dynamic evaluation of expressions based on the variable values.
 *
 * @schema StageSpecPromotionTemplateSpecStepsVars
 */
export interface StageSpecPromotionTemplateSpecStepsVars {
  /**
   * Name is the name of the variable.
   *
   * @schema StageSpecPromotionTemplateSpecStepsVars#name
   */
  readonly name: string;

  /**
   * Value is the value of the variable. It is allowed to utilize expressions
   * in the value.
   * See https://docs.kargo.io/user-guide/reference-docs/expressions for details.
   *
   * @schema StageSpecPromotionTemplateSpecStepsVars#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'StageSpecPromotionTemplateSpecStepsVars' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_StageSpecPromotionTemplateSpecStepsVars(obj: StageSpecPromotionTemplateSpecStepsVars | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kind is the type of the PromotionTask. Can be either PromotionTask or
 * ClusterPromotionTask, default is PromotionTask.
 *
 * @schema StageSpecPromotionTemplateSpecStepsTaskKind
 */
export enum StageSpecPromotionTemplateSpecStepsTaskKind {
  /** PromotionTask */
  PROMOTION_TASK = "PromotionTask",
  /** ClusterPromotionTask */
  CLUSTER_PROMOTION_TASK = "ClusterPromotionTask",
}


/**
 * Warehouse is a source of Freight.
 *
 * @schema Warehouse
 */
export class Warehouse extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Warehouse"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kargo.akuity.io/v1alpha1',
    kind: 'Warehouse',
  }

  /**
   * Renders a Kubernetes manifest for "Warehouse".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: WarehouseProps): any {
    return {
      ...Warehouse.GVK,
      ...toJson_WarehouseProps(props),
    };
  }

  /**
   * Defines a "Warehouse" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: WarehouseProps) {
    super(scope, id, {
      ...Warehouse.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Warehouse.GVK,
      ...toJson_WarehouseProps(resolved),
    };
  }
}

/**
 * Warehouse is a source of Freight.
 *
 * @schema Warehouse
 */
export interface WarehouseProps {
  /**
   * @schema Warehouse#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * Spec describes sources of artifacts.
   *
   * @schema Warehouse#spec
   */
  readonly spec: WarehouseSpec;

}

/**
 * Converts an object of type 'WarehouseProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WarehouseProps(obj: WarehouseProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_WarehouseSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Spec describes sources of artifacts.
 *
 * @schema WarehouseSpec
 */
export interface WarehouseSpec {
  /**
   * FreightCreationPolicy describes how Freight is created by this Warehouse.
   * This field is optional. When left unspecified, the field is implicitly
   * treated as if its value were "Automatic".
   *
   * Accepted values:
   *
   * - "Automatic": New Freight is created automatically when any new artifact
   * is discovered.
   * - "Manual": New Freight is never created automatically.
   *
   * @schema WarehouseSpec#freightCreationPolicy
   */
  readonly freightCreationPolicy?: WarehouseSpecFreightCreationPolicy;

  /**
   * Interval is the reconciliation interval for this Warehouse. On each
   * reconciliation, the Warehouse will discover new artifacts and optionally
   * produce new Freight. This field is optional. When left unspecified, the
   * field is implicitly treated as if its value were "5m0s".
   *
   * @schema WarehouseSpec#interval
   */
  readonly interval: string;

  /**
   * Shard is the name of the shard that this Warehouse belongs to. This is an
   * optional field. If not specified, the Warehouse will belong to the default
   * shard. A defaulting webhook will sync this field with the value of the
   * kargo.akuity.io/shard label. When the shard label is not present or differs
   * from the value of this field, the defaulting webhook will set the label to
   * the value of this field. If the shard label is present and this field is
   * empty, the defaulting webhook will set the value of this field to the value
   * of the shard label.
   *
   * @schema WarehouseSpec#shard
   */
  readonly shard?: string;

  /**
   * Subscriptions describes sources of artifacts to be included in Freight
   * produced by this Warehouse.
   *
   * @schema WarehouseSpec#subscriptions
   */
  readonly subscriptions: WarehouseSpecSubscriptions[];

}

/**
 * Converts an object of type 'WarehouseSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WarehouseSpec(obj: WarehouseSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'freightCreationPolicy': obj.freightCreationPolicy,
    'interval': obj.interval,
    'shard': obj.shard,
    'subscriptions': obj.subscriptions?.map(y => toJson_WarehouseSpecSubscriptions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * FreightCreationPolicy describes how Freight is created by this Warehouse.
 * This field is optional. When left unspecified, the field is implicitly
 * treated as if its value were "Automatic".
 *
 * Accepted values:
 *
 * - "Automatic": New Freight is created automatically when any new artifact
 * is discovered.
 * - "Manual": New Freight is never created automatically.
 *
 * @schema WarehouseSpecFreightCreationPolicy
 */
export enum WarehouseSpecFreightCreationPolicy {
  /** Automatic */
  AUTOMATIC = "Automatic",
  /** Manual */
  MANUAL = "Manual",
}

/**
 * RepoSubscription describes a subscription to ONE OF a Git repository, a
 * container image repository, or a Helm chart repository.
 *
 * @schema WarehouseSpecSubscriptions
 */
export interface WarehouseSpecSubscriptions {
  /**
   * Chart describes a subscription to a Helm chart repository.
   *
   * @schema WarehouseSpecSubscriptions#chart
   */
  readonly chart?: WarehouseSpecSubscriptionsChart;

  /**
   * Git describes a subscriptions to a Git repository.
   *
   * @schema WarehouseSpecSubscriptions#git
   */
  readonly git?: WarehouseSpecSubscriptionsGit;

  /**
   * Image describes a subscription to container image repository.
   *
   * @schema WarehouseSpecSubscriptions#image
   */
  readonly image?: WarehouseSpecSubscriptionsImage;

}

/**
 * Converts an object of type 'WarehouseSpecSubscriptions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WarehouseSpecSubscriptions(obj: WarehouseSpecSubscriptions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'chart': toJson_WarehouseSpecSubscriptionsChart(obj.chart),
    'git': toJson_WarehouseSpecSubscriptionsGit(obj.git),
    'image': toJson_WarehouseSpecSubscriptionsImage(obj.image),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Chart describes a subscription to a Helm chart repository.
 *
 * @schema WarehouseSpecSubscriptionsChart
 */
export interface WarehouseSpecSubscriptionsChart {
  /**
   * DiscoveryLimit is an optional limit on the number of chart versions that
   * can be discovered for this subscription. The limit is applied after
   * filtering charts based on the SemverConstraint field.
   * When left unspecified, the field is implicitly treated as if its value
   * were "20". The upper limit for this field is 100.
   *
   * @schema WarehouseSpecSubscriptionsChart#discoveryLimit
   */
  readonly discoveryLimit?: number;

  /**
   * Name specifies the name of a Helm chart to subscribe to within a classic
   * chart repository specified by the RepoURL field. This field is required
   * when the RepoURL field points to a classic chart repository and MUST
   * otherwise be empty.
   *
   * @schema WarehouseSpecSubscriptionsChart#name
   */
  readonly name?: string;

  /**
   * RepoURL specifies the URL of a Helm chart repository. It may be a classic
   * chart repository (using HTTP/S) OR a repository within an OCI registry.
   * Classic chart repositories can contain differently named charts. When this
   * field points to such a repository, the Name field MUST also be used
   * to specify the name of the desired chart within that repository. In the
   * case of a repository within an OCI registry, the URL implicitly points to
   * a specific chart and the Name field MUST NOT be used. The RepoURL field is
   * required.
   *
   * @schema WarehouseSpecSubscriptionsChart#repoURL
   */
  readonly repoUrl: string;

  /**
   * SemverConstraint specifies constraints on what new chart versions are
   * permissible. This field is optional. When left unspecified, there will be
   * no constraints, which means the latest version of the chart will always be
   * used. Care should be taken with leaving this field unspecified, as it can
   * lead to the unanticipated rollout of breaking changes.
   * More info: https://github.com/masterminds/semver#checking-version-constraints
   *
   * @schema WarehouseSpecSubscriptionsChart#semverConstraint
   */
  readonly semverConstraint?: string;

}

/**
 * Converts an object of type 'WarehouseSpecSubscriptionsChart' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WarehouseSpecSubscriptionsChart(obj: WarehouseSpecSubscriptionsChart | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'discoveryLimit': obj.discoveryLimit,
    'name': obj.name,
    'repoURL': obj.repoUrl,
    'semverConstraint': obj.semverConstraint,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Git describes a subscriptions to a Git repository.
 *
 * @schema WarehouseSpecSubscriptionsGit
 */
export interface WarehouseSpecSubscriptionsGit {
  /**
   * AllowTags is a regular expression that can optionally be used to limit the
   * tags that are considered in determining the newest commit of interest. The
   * value in this field only has any effect when the CommitSelectionStrategy is
   * Lexical, NewestTag, or SemVer. This field is optional.
   *
   * @schema WarehouseSpecSubscriptionsGit#allowTags
   */
  readonly allowTags?: string;

  /**
   * Branch references a particular branch of the repository. The value in this
   * field only has any effect when the CommitSelectionStrategy is
   * NewestFromBranch or left unspecified (which is implicitly the same as
   * NewestFromBranch). This field is optional. When left unspecified, (and the
   * CommitSelectionStrategy is NewestFromBranch or unspecified), the
   * subscription is implicitly to the repository's default branch.
   *
   * @schema WarehouseSpecSubscriptionsGit#branch
   */
  readonly branch?: string;

  /**
   * CommitSelectionStrategy specifies the rules for how to identify the newest
   * commit of interest in the repository specified by the RepoURL field. This
   * field is optional. When left unspecified, the field is implicitly treated
   * as if its value were "NewestFromBranch".
   *
   * Accepted values:
   *
   * - "NewestFromBranch": Selects the latest commit on the branch specified
   * by the Branch field or the default branch if none is specified. This is
   * the default strategy.
   *
   * - "SemVer": Selects the commit referenced by the semantically greatest
   * tag. The SemverConstraint field can optionally be used to narrow the set
   * of tags eligible for selection.
   *
   * - "Lexical": Selects the commit referenced by the lexicographically
   * greatest tag. Useful when tags embed a _leading_ date or timestamp. The
   * AllowTags and IgnoreTags fields can optionally be used to narrow the set
   * of tags eligible for selection.
   *
   * - "NewestTag": Selects the commit referenced by the most recently created
   * tag. The AllowTags and IgnoreTags fields can optionally be used to
   * narrow the set of tags eligible for selection.
   *
   * @schema WarehouseSpecSubscriptionsGit#commitSelectionStrategy
   */
  readonly commitSelectionStrategy?: WarehouseSpecSubscriptionsGitCommitSelectionStrategy;

  /**
   * DiscoveryLimit is an optional limit on the number of commits that can be
   * discovered for this subscription. The limit is applied after filtering
   * commits based on the AllowTags and IgnoreTags fields.
   * When left unspecified, the field is implicitly treated as if its value
   * were "20". The upper limit for this field is 100.
   *
   * @schema WarehouseSpecSubscriptionsGit#discoveryLimit
   */
  readonly discoveryLimit?: number;

  /**
   * ExcludePaths is a list of selectors that designate paths in the repository
   * that should NOT trigger the production of new Freight when changes are
   * detected therein. When specified, changes in the identified paths will not
   * trigger Freight production. When not specified, paths that should trigger
   * Freight production will be defined solely by IncludePaths. Selectors may be
   * defined using:
   * 1. Exact paths to files or directories (ex. "charts/foo")
   * 2. Glob patterns (prefix the pattern with "glob:"; ex. "glob:*.yaml")
   * 3. Regular expressions (prefix the pattern with "regex:" or "regexp:";
   * ex. "regexp:^.*\.yaml$")
   * Paths selected by IncludePaths may be unselected by ExcludePaths. This
   * is a useful method for including a broad set of paths and then excluding a
   * subset of them.
   *
   * @schema WarehouseSpecSubscriptionsGit#excludePaths
   */
  readonly excludePaths?: string[];

  /**
   * ExpressionFilter is an expression that can optionally be used to limit
   * the commits or tags that are considered in determining the newest commit
   * of interest based on their metadata.
   *
   * For commit-based strategies (NewestFromBranch), the filter applies to
   * commits and has access to commit metadata variables.
   * For tag-based strategies (Lexical, NewestTag, SemVer), the filter applies
   * to tags and has access to tag metadata variables. The filter is applied
   * after AllowTags, IgnoreTags, and SemverConstraint fields.
   *
   * The expression should be a valid expr-lang expression that evaluates to
   * true or false. When the expression evaluates to true, the commit/tag is
   * included in the set that is considered. When the expression evaluates to
   * false, the commit/tag is excluded.
   *
   * Available variables depend on the CommitSelectionStrategy:
   *
   * For NewestFromBranch (commit filtering):
   * - `id`: The ID (sha) of the commit.
   * - `commitDate`: The commit date of the commit.
   * - `author`: The author of the commit message, in the format "Name <email>".
   * - `committer`: The person who committed the commit, in the format
   * "Name <email>".
   * - `subject`: The subject (first line) of the commit message.
   *
   * For Lexical, NewestTag, SemVer (tag filtering):
   * - `tag`: The name of the tag.
   * - `id`: The ID (sha) of the commit associated with the tag.
   * - `creatorDate`: The creation date of an annotated tag, or the commit
   * date of a lightweight tag.
   * - `author`: The author of the commit message associated with the tag,
   * in the format "Name <email>".
   * - `committer`: The person who committed the commit associated with the
   * tag, in the format "Name <email>".
   * - `subject`: The subject (first line) of the commit message associated
   * with the tag.
   * - `tagger`: The person who created the tag, in the format "Name <email>".
   * Only available for annotated tags.
   * - `annotation`: The subject (first line) of the tag annotation. Only
   * available for annotated tags.
   *
   * Refer to the expr-lang documentation for more details on syntax and
   * capabilities of the expression language: https://expr-lang.org.
   *
   * @schema WarehouseSpecSubscriptionsGit#expressionFilter
   */
  readonly expressionFilter?: string;

  /**
   * IgnoreTags is a list of tags that must be ignored when determining the
   * newest commit of interest. No regular expressions or glob patterns are
   * supported yet. The value in this field only has any effect when the
   * CommitSelectionStrategy is Lexical, NewestTag, or SemVer. This field is
   * optional.
   *
   * @schema WarehouseSpecSubscriptionsGit#ignoreTags
   */
  readonly ignoreTags?: string[];

  /**
   * IncludePaths is a list of selectors that designate paths in the repository
   * that should trigger the production of new Freight when changes are detected
   * therein. When specified, only changes in the identified paths will trigger
   * Freight production. When not specified, changes in any path will trigger
   * Freight production. Selectors may be defined using:
   * 1. Exact paths to files or directories (ex. "charts/foo")
   * 2. Glob patterns (prefix the pattern with "glob:"; ex. "glob:*.yaml")
   * 3. Regular expressions (prefix the pattern with "regex:" or "regexp:";
   * ex. "regexp:^.*\.yaml$")
   *
   * Paths selected by IncludePaths may be unselected by ExcludePaths. This
   * is a useful method for including a broad set of paths and then excluding a
   * subset of them.
   *
   * @schema WarehouseSpecSubscriptionsGit#includePaths
   */
  readonly includePaths?: string[];

  /**
   * InsecureSkipTLSVerify specifies whether certificate verification errors
   * should be ignored when connecting to the repository. This should be enabled
   * only with great caution.
   *
   * @schema WarehouseSpecSubscriptionsGit#insecureSkipTLSVerify
   */
  readonly insecureSkipTlsVerify?: boolean;

  /**
   * URL is the repository's URL. This is a required field.
   *
   * @schema WarehouseSpecSubscriptionsGit#repoURL
   */
  readonly repoUrl: string;

  /**
   * SemverConstraint specifies constraints on what new tagged commits are
   * considered in determining the newest commit of interest. The value in this
   * field only has any effect when the CommitSelectionStrategy is SemVer. This
   * field is optional. When left unspecified, there will be no constraints,
   * which means the latest semantically tagged commit will always be used. Care
   * should be taken with leaving this field unspecified, as it can lead to the
   * unanticipated rollout of breaking changes.
   *
   * @schema WarehouseSpecSubscriptionsGit#semverConstraint
   */
  readonly semverConstraint?: string;

  /**
   * StrictSemvers specifies whether only "strict" semver tags should be
   * considered. A "strict" semver tag is one containing ALL of major, minor,
   * and patch version components. This is enabled by default, but only has any
   * effect when the CommitSelectionStrategy is SemVer. This should be disabled
   * cautiously, as it creates the potential for any tag containing numeric
   * characters only to be mistaken for a semver string containing the major
   * version number only.
   *
   * @schema WarehouseSpecSubscriptionsGit#strictSemvers
   */
  readonly strictSemvers: boolean;

}

/**
 * Converts an object of type 'WarehouseSpecSubscriptionsGit' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WarehouseSpecSubscriptionsGit(obj: WarehouseSpecSubscriptionsGit | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowTags': obj.allowTags,
    'branch': obj.branch,
    'commitSelectionStrategy': obj.commitSelectionStrategy,
    'discoveryLimit': obj.discoveryLimit,
    'excludePaths': obj.excludePaths?.map(y => y),
    'expressionFilter': obj.expressionFilter,
    'ignoreTags': obj.ignoreTags?.map(y => y),
    'includePaths': obj.includePaths?.map(y => y),
    'insecureSkipTLSVerify': obj.insecureSkipTlsVerify,
    'repoURL': obj.repoUrl,
    'semverConstraint': obj.semverConstraint,
    'strictSemvers': obj.strictSemvers,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Image describes a subscription to container image repository.
 *
 * @schema WarehouseSpecSubscriptionsImage
 */
export interface WarehouseSpecSubscriptionsImage {
  /**
   * AllowTags is a regular expression that can optionally be used to limit the
   * image tags that are considered in determining the newest version of an
   * image. This field is optional.
   *
   * @schema WarehouseSpecSubscriptionsImage#allowTags
   */
  readonly allowTags?: string;

  /**
   * DiscoveryLimit is an optional limit on the number of image references
   * that can be discovered for this subscription. The limit is applied after
   * filtering images based on the AllowTags and IgnoreTags fields.
   * When left unspecified, the field is implicitly treated as if its value
   * were "20". The upper limit for this field is 100.
   *
   * @schema WarehouseSpecSubscriptionsImage#discoveryLimit
   */
  readonly discoveryLimit?: number;

  /**
   * GitRepoURL optionally specifies the URL of a Git repository that contains
   * the source code for the image repository referenced by the RepoURL field.
   * When this is specified, Kargo MAY be able to infer and link to the exact
   * revision of that source code that was used to build the image.
   *
   * Deprecated: Use OCI annotations instead. Will be removed in v1.7.0.
   *
   * @schema WarehouseSpecSubscriptionsImage#gitRepoURL
   */
  readonly gitRepoUrl?: string;

  /**
   * IgnoreTags is a list of tags that must be ignored when determining the
   * newest version of an image. No regular expressions or glob patterns are
   * supported yet. This field is optional.
   *
   * @schema WarehouseSpecSubscriptionsImage#ignoreTags
   */
  readonly ignoreTags?: string[];

  /**
   * ImageSelectionStrategy specifies the rules for how to identify the newest version
   * of the image specified by the RepoURL field. This field is optional. When
   * left unspecified, the field is implicitly treated as if its value were
   * "SemVer".
   *
   * Accepted values:
   *
   * - "Digest": Selects the image currently referenced by the tag specified
   * (unintuitively) by the SemverConstraint field.
   *
   * - "Lexical": Selects the image referenced by the lexicographically greatest
   * tag. Useful when tags embed a leading date or timestamp. The AllowTags
   * and IgnoreTags fields can optionally be used to narrow the set of tags
   * eligible for selection.
   *
   * - "NewestBuild": Selects the image that was most recently pushed to the
   * repository. The AllowTags and IgnoreTags fields can optionally be used
   * to narrow the set of tags eligible for selection. This is the least
   * efficient and is likely to cause rate limiting affecting this Warehouse
   * and possibly others. This strategy should be avoided.
   *
   * - "SemVer": Selects the image with the semantically greatest tag. The
   * AllowTags and IgnoreTags fields can optionally be used to narrow the set
   * of tags eligible for selection.
   *
   * @schema WarehouseSpecSubscriptionsImage#imageSelectionStrategy
   */
  readonly imageSelectionStrategy?: WarehouseSpecSubscriptionsImageImageSelectionStrategy;

  /**
   * InsecureSkipTLSVerify specifies whether certificate verification errors
   * should be ignored when connecting to the repository. This should be enabled
   * only with great caution.
   *
   * @schema WarehouseSpecSubscriptionsImage#insecureSkipTLSVerify
   */
  readonly insecureSkipTlsVerify?: boolean;

  /**
   * Platform is a string of the form <os>/<arch> that limits the tags that can
   * be considered when searching for new versions of an image. This field is
   * optional. When left unspecified, it is implicitly equivalent to the
   * OS/architecture of the Kargo controller. Care should be taken to set this
   * value correctly in cases where the image referenced by this
   * ImageRepositorySubscription will run on a Kubernetes node with a different
   * OS/architecture than the Kargo controller. At present this is uncommon, but
   * not unheard of.
   *
   * @schema WarehouseSpecSubscriptionsImage#platform
   */
  readonly platform?: string;

  /**
   * RepoURL specifies the URL of the image repository to subscribe to. The
   * value in this field MUST NOT include an image tag. This field is required.
   *
   * @schema WarehouseSpecSubscriptionsImage#repoURL
   */
  readonly repoUrl: string;

  /**
   * SemverConstraint specifies constraints on what new image versions are
   * permissible. The value in this field only has any effect when the
   * ImageSelectionStrategy is SemVer or left unspecified (which is implicitly
   * the same as SemVer). This field is also optional. When left unspecified,
   * (and the ImageSelectionStrategy is SemVer or unspecified), there will be no
   * constraints, which means the latest semantically tagged version of an image
   * will always be used. Care should be taken with leaving this field
   * unspecified, as it can lead to the unanticipated rollout of breaking
   * changes.
   * More info: https://github.com/masterminds/semver#checking-version-constraints
   *
   * @schema WarehouseSpecSubscriptionsImage#semverConstraint
   */
  readonly semverConstraint?: string;

  /**
   * StrictSemvers specifies whether only "strict" semver tags should be
   * considered. A "strict" semver tag is one containing ALL of major, minor,
   * and patch version components. This is enabled by default, but only has any
   * effect when the ImageSelectionStrategy is SemVer. This should be disabled
   * cautiously, as it is not uncommon to tag container images with short Git
   * commit hashes, which have the potential to contain numeric characters only
   * and could be mistaken for a semver string containing the major version
   * number only.
   *
   * @schema WarehouseSpecSubscriptionsImage#strictSemvers
   */
  readonly strictSemvers: boolean;

}

/**
 * Converts an object of type 'WarehouseSpecSubscriptionsImage' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_WarehouseSpecSubscriptionsImage(obj: WarehouseSpecSubscriptionsImage | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'allowTags': obj.allowTags,
    'discoveryLimit': obj.discoveryLimit,
    'gitRepoURL': obj.gitRepoUrl,
    'ignoreTags': obj.ignoreTags?.map(y => y),
    'imageSelectionStrategy': obj.imageSelectionStrategy,
    'insecureSkipTLSVerify': obj.insecureSkipTlsVerify,
    'platform': obj.platform,
    'repoURL': obj.repoUrl,
    'semverConstraint': obj.semverConstraint,
    'strictSemvers': obj.strictSemvers,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CommitSelectionStrategy specifies the rules for how to identify the newest
 * commit of interest in the repository specified by the RepoURL field. This
 * field is optional. When left unspecified, the field is implicitly treated
 * as if its value were "NewestFromBranch".
 *
 * Accepted values:
 *
 * - "NewestFromBranch": Selects the latest commit on the branch specified
 * by the Branch field or the default branch if none is specified. This is
 * the default strategy.
 *
 * - "SemVer": Selects the commit referenced by the semantically greatest
 * tag. The SemverConstraint field can optionally be used to narrow the set
 * of tags eligible for selection.
 *
 * - "Lexical": Selects the commit referenced by the lexicographically
 * greatest tag. Useful when tags embed a _leading_ date or timestamp. The
 * AllowTags and IgnoreTags fields can optionally be used to narrow the set
 * of tags eligible for selection.
 *
 * - "NewestTag": Selects the commit referenced by the most recently created
 * tag. The AllowTags and IgnoreTags fields can optionally be used to
 * narrow the set of tags eligible for selection.
 *
 * @schema WarehouseSpecSubscriptionsGitCommitSelectionStrategy
 */
export enum WarehouseSpecSubscriptionsGitCommitSelectionStrategy {
  /** Lexical */
  LEXICAL = "Lexical",
  /** NewestFromBranch */
  NEWEST_FROM_BRANCH = "NewestFromBranch",
  /** NewestTag */
  NEWEST_TAG = "NewestTag",
  /** SemVer */
  SEM_VER = "SemVer",
}

/**
 * ImageSelectionStrategy specifies the rules for how to identify the newest version
 * of the image specified by the RepoURL field. This field is optional. When
 * left unspecified, the field is implicitly treated as if its value were
 * "SemVer".
 *
 * Accepted values:
 *
 * - "Digest": Selects the image currently referenced by the tag specified
 * (unintuitively) by the SemverConstraint field.
 *
 * - "Lexical": Selects the image referenced by the lexicographically greatest
 * tag. Useful when tags embed a leading date or timestamp. The AllowTags
 * and IgnoreTags fields can optionally be used to narrow the set of tags
 * eligible for selection.
 *
 * - "NewestBuild": Selects the image that was most recently pushed to the
 * repository. The AllowTags and IgnoreTags fields can optionally be used
 * to narrow the set of tags eligible for selection. This is the least
 * efficient and is likely to cause rate limiting affecting this Warehouse
 * and possibly others. This strategy should be avoided.
 *
 * - "SemVer": Selects the image with the semantically greatest tag. The
 * AllowTags and IgnoreTags fields can optionally be used to narrow the set
 * of tags eligible for selection.
 *
 * @schema WarehouseSpecSubscriptionsImageImageSelectionStrategy
 */
export enum WarehouseSpecSubscriptionsImageImageSelectionStrategy {
  /** Digest */
  DIGEST = "Digest",
  /** Lexical */
  LEXICAL = "Lexical",
  /** NewestBuild */
  NEWEST_BUILD = "NewestBuild",
  /** SemVer */
  SEM_VER = "SemVer",
}

