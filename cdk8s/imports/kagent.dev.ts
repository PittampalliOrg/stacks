// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * Agent is the Schema for the agents API.
 *
 * @schema Agent
 */
export class Agent extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Agent"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kagent.dev/v1alpha1',
    kind: 'Agent',
  }

  /**
   * Renders a Kubernetes manifest for "Agent".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: AgentProps = {}): any {
    return {
      ...Agent.GVK,
      ...toJson_AgentProps(props),
    };
  }

  /**
   * Defines a "Agent" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: AgentProps = {}) {
    super(scope, id, {
      ...Agent.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Agent.GVK,
      ...toJson_AgentProps(resolved),
    };
  }
}

/**
 * Agent is the Schema for the agents API.
 *
 * @schema Agent
 */
export interface AgentProps {
  /**
   * @schema Agent#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * AgentSpec defines the desired state of Agent.
   *
   * @schema Agent#spec
   */
  readonly spec?: AgentSpec;

}

/**
 * Converts an object of type 'AgentProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentProps(obj: AgentProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_AgentSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AgentSpec defines the desired state of Agent.
 *
 * @schema AgentSpec
 */
export interface AgentSpec {
  /**
   * A2AConfig instantiates an A2A server for this agent,
   * served on the HTTP port of the kagent kubernetes
   * controller (default 8083).
   * The A2A server URL will be served at
   * <kagent-controller-ip>:8083/api/a2a/<agent-namespace>/<agent-name>
   * Read more about the A2A protocol here: https://github.com/google/A2A
   *
   * @schema AgentSpec#a2aConfig
   */
  readonly a2AConfig?: AgentSpecA2AConfig;

  /**
   * @schema AgentSpec#description
   */
  readonly description?: string;

  /**
   * Can either be a reference to the name of a Memory in the same namespace as the referencing Agent, or a reference to the name of a Memory in a different namespace in the form <namespace>/<name>
   *
   * @schema AgentSpec#memory
   */
  readonly memory?: string[];

  /**
   * Can either be a reference to the name of a ModelConfig in the same namespace as the referencing Agent, or a reference to the name of a ModelConfig in a different namespace in the form <namespace>/<name>
   *
   * @schema AgentSpec#modelConfig
   */
  readonly modelConfig?: string;

  /**
   * Whether to stream the response from the model.
   * If not specified, the default value is true.
   *
   * @schema AgentSpec#stream
   */
  readonly stream?: boolean;

  /**
   * @schema AgentSpec#systemMessage
   */
  readonly systemMessage?: string;

  /**
   * @schema AgentSpec#tools
   */
  readonly tools?: AgentSpecTools[];

}

/**
 * Converts an object of type 'AgentSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentSpec(obj: AgentSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'a2aConfig': toJson_AgentSpecA2AConfig(obj.a2AConfig),
    'description': obj.description,
    'memory': obj.memory?.map(y => y),
    'modelConfig': obj.modelConfig,
    'stream': obj.stream,
    'systemMessage': obj.systemMessage,
    'tools': obj.tools?.map(y => toJson_AgentSpecTools(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A2AConfig instantiates an A2A server for this agent,
 * served on the HTTP port of the kagent kubernetes
 * controller (default 8083).
 * The A2A server URL will be served at
 * <kagent-controller-ip>:8083/api/a2a/<agent-namespace>/<agent-name>
 * Read more about the A2A protocol here: https://github.com/google/A2A
 *
 * @schema AgentSpecA2AConfig
 */
export interface AgentSpecA2AConfig {
  /**
   * @schema AgentSpecA2AConfig#skills
   */
  readonly skills?: AgentSpecA2AConfigSkills[];

}

/**
 * Converts an object of type 'AgentSpecA2AConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentSpecA2AConfig(obj: AgentSpecA2AConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'skills': obj.skills?.map(y => toJson_AgentSpecA2AConfigSkills(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AgentSpecTools
 */
export interface AgentSpecTools {
  /**
   * @schema AgentSpecTools#agent
   */
  readonly agent?: AgentSpecToolsAgent;

  /**
   * @schema AgentSpecTools#mcpServer
   */
  readonly mcpServer?: AgentSpecToolsMcpServer;

  /**
   * ToolProviderType represents the tool provider type
   *
   * @schema AgentSpecTools#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'AgentSpecTools' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentSpecTools(obj: AgentSpecTools | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'agent': toJson_AgentSpecToolsAgent(obj.agent),
    'mcpServer': toJson_AgentSpecToolsMcpServer(obj.mcpServer),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AgentSkill describes a specific capability or function of the agent.
 *
 * @schema AgentSpecA2AConfigSkills
 */
export interface AgentSpecA2AConfigSkills {
  /**
   * Description is an optional detailed description of the skill.
   *
   * @schema AgentSpecA2AConfigSkills#description
   */
  readonly description?: string;

  /**
   * Examples are optional usage examples.
   *
   * @schema AgentSpecA2AConfigSkills#examples
   */
  readonly examples?: string[];

  /**
   * ID is the unique identifier for the skill.
   *
   * @schema AgentSpecA2AConfigSkills#id
   */
  readonly id: string;

  /**
   * InputModes are the supported input data modes/types.
   *
   * @schema AgentSpecA2AConfigSkills#inputModes
   */
  readonly inputModes?: string[];

  /**
   * Name is the human-readable name of the skill.
   *
   * @schema AgentSpecA2AConfigSkills#name
   */
  readonly name: string;

  /**
   * OutputModes are the supported output data modes/types.
   *
   * @schema AgentSpecA2AConfigSkills#outputModes
   */
  readonly outputModes?: string[];

  /**
   * Tags are optional tags for categorization.
   *
   * @schema AgentSpecA2AConfigSkills#tags
   */
  readonly tags?: string[];

}

/**
 * Converts an object of type 'AgentSpecA2AConfigSkills' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentSpecA2AConfigSkills(obj: AgentSpecA2AConfigSkills | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'examples': obj.examples?.map(y => y),
    'id': obj.id,
    'inputModes': obj.inputModes?.map(y => y),
    'name': obj.name,
    'outputModes': obj.outputModes?.map(y => y),
    'tags': obj.tags?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AgentSpecToolsAgent
 */
export interface AgentSpecToolsAgent {
  /**
   * Reference to the Agent resource to use as a tool.
   * Can either be a reference to the name of an Agent in the same namespace as the referencing Agent, or a reference to the name of an Agent in a different namespace in the form <namespace>/<name>
   *
   * @schema AgentSpecToolsAgent#ref
   */
  readonly ref?: string;

}

/**
 * Converts an object of type 'AgentSpecToolsAgent' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentSpecToolsAgent(obj: AgentSpecToolsAgent | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'ref': obj.ref,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema AgentSpecToolsMcpServer
 */
export interface AgentSpecToolsMcpServer {
  /**
   * The names of the tools to be provided by the ToolServer
   * For a list of all the tools provided by the server,
   * the client can query the status of the ToolServer object after it has been created
   *
   * @schema AgentSpecToolsMcpServer#toolNames
   */
  readonly toolNames?: string[];

  /**
   * the name of the ToolServer that provides the tool. can either be a reference to the name of a ToolServer in the same namespace as the referencing Agent, or a reference to the name of an ToolServer in a different namespace in the form <namespace>/<name>
   *
   * @schema AgentSpecToolsMcpServer#toolServer
   */
  readonly toolServer?: string;

}

/**
 * Converts an object of type 'AgentSpecToolsMcpServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_AgentSpecToolsMcpServer(obj: AgentSpecToolsMcpServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'toolNames': obj.toolNames?.map(y => y),
    'toolServer': obj.toolServer,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * Memory is the Schema for the memories API.
 *
 * @schema Memory
 */
export class Memory extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Memory"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kagent.dev/v1alpha1',
    kind: 'Memory',
  }

  /**
   * Renders a Kubernetes manifest for "Memory".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: MemoryProps = {}): any {
    return {
      ...Memory.GVK,
      ...toJson_MemoryProps(props),
    };
  }

  /**
   * Defines a "Memory" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: MemoryProps = {}) {
    super(scope, id, {
      ...Memory.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Memory.GVK,
      ...toJson_MemoryProps(resolved),
    };
  }
}

/**
 * Memory is the Schema for the memories API.
 *
 * @schema Memory
 */
export interface MemoryProps {
  /**
   * @schema Memory#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * MemorySpec defines the desired state of Memory.
   *
   * @schema Memory#spec
   */
  readonly spec?: MemorySpec;

}

/**
 * Converts an object of type 'MemoryProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_MemoryProps(obj: MemoryProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_MemorySpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * MemorySpec defines the desired state of Memory.
 *
 * @schema MemorySpec
 */
export interface MemorySpec {
  /**
   * The key in the secret that contains the API key
   *
   * @schema MemorySpec#apiKeySecretKey
   */
  readonly apiKeySecretKey?: string;

  /**
   * The reference to the secret that contains the API key. Can either be a reference to the name of a secret in the same namespace as the referencing Memory,
   * or a reference to the name of a secret in a different namespace in the form <namespace>/<name>
   *
   * @schema MemorySpec#apiKeySecretRef
   */
  readonly apiKeySecretRef?: string;

  /**
   * The configuration for the Pinecone memory provider
   *
   * @schema MemorySpec#pinecone
   */
  readonly pinecone?: MemorySpecPinecone;

  /**
   * The provider of the memory
   *
   * @schema MemorySpec#provider
   */
  readonly provider: MemorySpecProvider;

}

/**
 * Converts an object of type 'MemorySpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_MemorySpec(obj: MemorySpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiKeySecretKey': obj.apiKeySecretKey,
    'apiKeySecretRef': obj.apiKeySecretRef,
    'pinecone': toJson_MemorySpecPinecone(obj.pinecone),
    'provider': obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The configuration for the Pinecone memory provider
 *
 * @schema MemorySpecPinecone
 */
export interface MemorySpecPinecone {
  /**
   * The index host to connect to
   *
   * @schema MemorySpecPinecone#indexHost
   */
  readonly indexHost: string;

  /**
   * The namespace to use for the Pinecone index. If not provided, the default namespace will be used.
   *
   * @schema MemorySpecPinecone#namespace
   */
  readonly namespace?: string;

  /**
   * The fields to retrieve from the Pinecone index. If not provided, all fields will be retrieved.
   *
   * @schema MemorySpecPinecone#recordFields
   */
  readonly recordFields?: string[];

  /**
   * The score threshold of results to include in the context. Results with a score below this threshold will be ignored.
   *
   * @schema MemorySpecPinecone#scoreThreshold
   */
  readonly scoreThreshold?: string;

  /**
   * The number of results to return from the Pinecone index
   *
   * @schema MemorySpecPinecone#topK
   */
  readonly topK?: number;

}

/**
 * Converts an object of type 'MemorySpecPinecone' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_MemorySpecPinecone(obj: MemorySpecPinecone | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'indexHost': obj.indexHost,
    'namespace': obj.namespace,
    'recordFields': obj.recordFields?.map(y => y),
    'scoreThreshold': obj.scoreThreshold,
    'topK': obj.topK,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider of the memory
 *
 * @schema MemorySpecProvider
 */
export enum MemorySpecProvider {
  /** Pinecone */
  PINECONE = "Pinecone",
}


/**
 * ModelConfig is the Schema for the modelconfigs API.
 *
 * @schema ModelConfig
 */
export class ModelConfig extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ModelConfig"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kagent.dev/v1alpha1',
    kind: 'ModelConfig',
  }

  /**
   * Renders a Kubernetes manifest for "ModelConfig".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ModelConfigProps = {}): any {
    return {
      ...ModelConfig.GVK,
      ...toJson_ModelConfigProps(props),
    };
  }

  /**
   * Defines a "ModelConfig" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ModelConfigProps = {}) {
    super(scope, id, {
      ...ModelConfig.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ModelConfig.GVK,
      ...toJson_ModelConfigProps(resolved),
    };
  }
}

/**
 * ModelConfig is the Schema for the modelconfigs API.
 *
 * @schema ModelConfig
 */
export interface ModelConfigProps {
  /**
   * @schema ModelConfig#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * @schema ModelConfig#spec
   */
  readonly spec?: ModelConfigSpec;

}

/**
 * Converts an object of type 'ModelConfigProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigProps(obj: ModelConfigProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ModelConfigSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ModelConfigSpec
 */
export interface ModelConfigSpec {
  /**
   * Anthropic-specific configuration
   *
   * @schema ModelConfigSpec#anthropic
   */
  readonly anthropic?: ModelConfigSpecAnthropic;

  /**
   * Anthropic-specific configuration
   *
   * @schema ModelConfigSpec#anthropicVertexAI
   */
  readonly anthropicVertexAi?: ModelConfigSpecAnthropicVertexAi;

  /**
   * The key in the secret that contains the API key
   *
   * @schema ModelConfigSpec#apiKeySecretKey
   */
  readonly apiKeySecretKey?: string;

  /**
   * The reference to the secret that contains the API key. Can either be a reference to the name of a secret in the same namespace as the referencing ModelConfig, or a reference to the name of a Secret in a different namespace in the form <namespace>/<name>
   *
   * @schema ModelConfigSpec#apiKeySecretRef
   */
  readonly apiKeySecretRef?: string;

  /**
   * Azure OpenAI-specific configuration
   *
   * @schema ModelConfigSpec#azureOpenAI
   */
  readonly azureOpenAi?: ModelConfigSpecAzureOpenAi;

  /**
   * @schema ModelConfigSpec#defaultHeaders
   */
  readonly defaultHeaders?: { [key: string]: string };

  /**
   * Gemini-specific configuration
   *
   * @schema ModelConfigSpec#geminiVertexAI
   */
  readonly geminiVertexAi?: ModelConfigSpecGeminiVertexAi;

  /**
   * @schema ModelConfigSpec#model
   */
  readonly model: string;

  /**
   * ModelInfo contains information about the model.
   * This field is required if the model is not one of the
   * pre-defined autogen models. That list can be found here:
   *
   * @schema ModelConfigSpec#modelInfo
   */
  readonly modelInfo?: ModelConfigSpecModelInfo;

  /**
   * Ollama-specific configuration
   *
   * @schema ModelConfigSpec#ollama
   */
  readonly ollama?: ModelConfigSpecOllama;

  /**
   * OpenAI-specific configuration
   *
   * @schema ModelConfigSpec#openAI
   */
  readonly openAi?: ModelConfigSpecOpenAi;

  /**
   * The provider of the model
   *
   * @schema ModelConfigSpec#provider
   */
  readonly provider: ModelConfigSpecProvider;

}

/**
 * Converts an object of type 'ModelConfigSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpec(obj: ModelConfigSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'anthropic': toJson_ModelConfigSpecAnthropic(obj.anthropic),
    'anthropicVertexAI': toJson_ModelConfigSpecAnthropicVertexAi(obj.anthropicVertexAi),
    'apiKeySecretKey': obj.apiKeySecretKey,
    'apiKeySecretRef': obj.apiKeySecretRef,
    'azureOpenAI': toJson_ModelConfigSpecAzureOpenAi(obj.azureOpenAi),
    'defaultHeaders': ((obj.defaultHeaders) === undefined) ? undefined : (Object.entries(obj.defaultHeaders).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'geminiVertexAI': toJson_ModelConfigSpecGeminiVertexAi(obj.geminiVertexAi),
    'model': obj.model,
    'modelInfo': toJson_ModelConfigSpecModelInfo(obj.modelInfo),
    'ollama': toJson_ModelConfigSpecOllama(obj.ollama),
    'openAI': toJson_ModelConfigSpecOpenAi(obj.openAi),
    'provider': obj.provider,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Anthropic-specific configuration
 *
 * @schema ModelConfigSpecAnthropic
 */
export interface ModelConfigSpecAnthropic {
  /**
   * Base URL for the Anthropic API (overrides default)
   *
   * @schema ModelConfigSpecAnthropic#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * Maximum tokens to generate
   *
   * @schema ModelConfigSpecAnthropic#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * Temperature for sampling
   *
   * @schema ModelConfigSpecAnthropic#temperature
   */
  readonly temperature?: string;

  /**
   * Top-k sampling parameter
   *
   * @schema ModelConfigSpecAnthropic#topK
   */
  readonly topK?: number;

  /**
   * Top-p sampling parameter
   *
   * @schema ModelConfigSpecAnthropic#topP
   */
  readonly topP?: string;

}

/**
 * Converts an object of type 'ModelConfigSpecAnthropic' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecAnthropic(obj: ModelConfigSpecAnthropic | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'maxTokens': obj.maxTokens,
    'temperature': obj.temperature,
    'topK': obj.topK,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Anthropic-specific configuration
 *
 * @schema ModelConfigSpecAnthropicVertexAi
 */
export interface ModelConfigSpecAnthropicVertexAi {
  /**
   * The project location
   *
   * @schema ModelConfigSpecAnthropicVertexAi#location
   */
  readonly location: string;

  /**
   * Maximum tokens to generate
   *
   * @schema ModelConfigSpecAnthropicVertexAi#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * The project ID
   *
   * @schema ModelConfigSpecAnthropicVertexAi#projectID
   */
  readonly projectId: string;

  /**
   * Stop sequences
   *
   * @schema ModelConfigSpecAnthropicVertexAi#stopSequences
   */
  readonly stopSequences?: string[];

  /**
   * Temperature
   *
   * @schema ModelConfigSpecAnthropicVertexAi#temperature
   */
  readonly temperature?: string;

  /**
   * Top-k sampling parameter
   *
   * @schema ModelConfigSpecAnthropicVertexAi#topK
   */
  readonly topK?: string;

  /**
   * Top-p sampling parameter
   *
   * @schema ModelConfigSpecAnthropicVertexAi#topP
   */
  readonly topP?: string;

}

/**
 * Converts an object of type 'ModelConfigSpecAnthropicVertexAi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecAnthropicVertexAi(obj: ModelConfigSpecAnthropicVertexAi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'location': obj.location,
    'maxTokens': obj.maxTokens,
    'projectID': obj.projectId,
    'stopSequences': obj.stopSequences?.map(y => y),
    'temperature': obj.temperature,
    'topK': obj.topK,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Azure OpenAI-specific configuration
 *
 * @schema ModelConfigSpecAzureOpenAi
 */
export interface ModelConfigSpecAzureOpenAi {
  /**
   * API version for the Azure OpenAI API
   *
   * @schema ModelConfigSpecAzureOpenAi#apiVersion
   */
  readonly apiVersion: string;

  /**
   * Azure AD token for authentication
   *
   * @schema ModelConfigSpecAzureOpenAi#azureAdToken
   */
  readonly azureAdToken?: string;

  /**
   * Deployment name for the Azure OpenAI API
   *
   * @schema ModelConfigSpecAzureOpenAi#azureDeployment
   */
  readonly azureDeployment?: string;

  /**
   * Endpoint for the Azure OpenAI API
   *
   * @schema ModelConfigSpecAzureOpenAi#azureEndpoint
   */
  readonly azureEndpoint: string;

  /**
   * Maximum tokens to generate
   *
   * @schema ModelConfigSpecAzureOpenAi#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * Temperature for sampling
   *
   * @schema ModelConfigSpecAzureOpenAi#temperature
   */
  readonly temperature?: string;

  /**
   * Top-p sampling parameter
   *
   * @schema ModelConfigSpecAzureOpenAi#topP
   */
  readonly topP?: string;

}

/**
 * Converts an object of type 'ModelConfigSpecAzureOpenAi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecAzureOpenAi(obj: ModelConfigSpecAzureOpenAi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'azureAdToken': obj.azureAdToken,
    'azureDeployment': obj.azureDeployment,
    'azureEndpoint': obj.azureEndpoint,
    'maxTokens': obj.maxTokens,
    'temperature': obj.temperature,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Gemini-specific configuration
 *
 * @schema ModelConfigSpecGeminiVertexAi
 */
export interface ModelConfigSpecGeminiVertexAi {
  /**
   * Candidate count
   *
   * @schema ModelConfigSpecGeminiVertexAi#candidateCount
   */
  readonly candidateCount?: number;

  /**
   * The project location
   *
   * @schema ModelConfigSpecGeminiVertexAi#location
   */
  readonly location: string;

  /**
   * Maximum output tokens
   *
   * @schema ModelConfigSpecGeminiVertexAi#maxOutputTokens
   */
  readonly maxOutputTokens?: number;

  /**
   * The project ID
   *
   * @schema ModelConfigSpecGeminiVertexAi#projectID
   */
  readonly projectId: string;

  /**
   * Response mime type
   *
   * @schema ModelConfigSpecGeminiVertexAi#responseMimeType
   */
  readonly responseMimeType?: string;

  /**
   * Stop sequences
   *
   * @schema ModelConfigSpecGeminiVertexAi#stopSequences
   */
  readonly stopSequences?: string[];

  /**
   * Temperature
   *
   * @schema ModelConfigSpecGeminiVertexAi#temperature
   */
  readonly temperature?: string;

  /**
   * Top-k sampling parameter
   *
   * @schema ModelConfigSpecGeminiVertexAi#topK
   */
  readonly topK?: string;

  /**
   * Top-p sampling parameter
   *
   * @schema ModelConfigSpecGeminiVertexAi#topP
   */
  readonly topP?: string;

}

/**
 * Converts an object of type 'ModelConfigSpecGeminiVertexAi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecGeminiVertexAi(obj: ModelConfigSpecGeminiVertexAi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'candidateCount': obj.candidateCount,
    'location': obj.location,
    'maxOutputTokens': obj.maxOutputTokens,
    'projectID': obj.projectId,
    'responseMimeType': obj.responseMimeType,
    'stopSequences': obj.stopSequences?.map(y => y),
    'temperature': obj.temperature,
    'topK': obj.topK,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ModelInfo contains information about the model.
 * This field is required if the model is not one of the
 * pre-defined autogen models. That list can be found here:
 *
 * @schema ModelConfigSpecModelInfo
 */
export interface ModelConfigSpecModelInfo {
  /**
   * @schema ModelConfigSpecModelInfo#family
   */
  readonly family?: string;

  /**
   * @schema ModelConfigSpecModelInfo#functionCalling
   */
  readonly functionCalling?: boolean;

  /**
   * @schema ModelConfigSpecModelInfo#jsonOutput
   */
  readonly jsonOutput?: boolean;

  /**
   * @schema ModelConfigSpecModelInfo#multipleSystemMessages
   */
  readonly multipleSystemMessages?: boolean;

  /**
   * @schema ModelConfigSpecModelInfo#structuredOutput
   */
  readonly structuredOutput?: boolean;

  /**
   * @schema ModelConfigSpecModelInfo#vision
   */
  readonly vision?: boolean;

}

/**
 * Converts an object of type 'ModelConfigSpecModelInfo' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecModelInfo(obj: ModelConfigSpecModelInfo | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'family': obj.family,
    'functionCalling': obj.functionCalling,
    'jsonOutput': obj.jsonOutput,
    'multipleSystemMessages': obj.multipleSystemMessages,
    'structuredOutput': obj.structuredOutput,
    'vision': obj.vision,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ollama-specific configuration
 *
 * @schema ModelConfigSpecOllama
 */
export interface ModelConfigSpecOllama {
  /**
   * Host for the Ollama API
   *
   * @schema ModelConfigSpecOllama#host
   */
  readonly host?: string;

  /**
   * Options for the Ollama API
   *
   * @schema ModelConfigSpecOllama#options
   */
  readonly options?: { [key: string]: string };

}

/**
 * Converts an object of type 'ModelConfigSpecOllama' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecOllama(obj: ModelConfigSpecOllama | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'host': obj.host,
    'options': ((obj.options) === undefined) ? undefined : (Object.entries(obj.options).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OpenAI-specific configuration
 *
 * @schema ModelConfigSpecOpenAi
 */
export interface ModelConfigSpecOpenAi {
  /**
   * Base URL for the OpenAI API (overrides default)
   *
   * @schema ModelConfigSpecOpenAi#baseUrl
   */
  readonly baseUrl?: string;

  /**
   * Frequency penalty
   *
   * @schema ModelConfigSpecOpenAi#frequencyPenalty
   */
  readonly frequencyPenalty?: string;

  /**
   * Maximum tokens to generate
   *
   * @schema ModelConfigSpecOpenAi#maxTokens
   */
  readonly maxTokens?: number;

  /**
   * N value
   *
   * @schema ModelConfigSpecOpenAi#n
   */
  readonly n?: number;

  /**
   * Organization ID for the OpenAI API
   *
   * @schema ModelConfigSpecOpenAi#organization
   */
  readonly organization?: string;

  /**
   * Presence penalty
   *
   * @schema ModelConfigSpecOpenAi#presencePenalty
   */
  readonly presencePenalty?: string;

  /**
   * Seed value
   *
   * @schema ModelConfigSpecOpenAi#seed
   */
  readonly seed?: number;

  /**
   * Temperature for sampling
   *
   * @schema ModelConfigSpecOpenAi#temperature
   */
  readonly temperature?: string;

  /**
   * Timeout
   *
   * @schema ModelConfigSpecOpenAi#timeout
   */
  readonly timeout?: number;

  /**
   * Top-p sampling parameter
   *
   * @schema ModelConfigSpecOpenAi#topP
   */
  readonly topP?: string;

}

/**
 * Converts an object of type 'ModelConfigSpecOpenAi' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ModelConfigSpecOpenAi(obj: ModelConfigSpecOpenAi | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'baseUrl': obj.baseUrl,
    'frequencyPenalty': obj.frequencyPenalty,
    'maxTokens': obj.maxTokens,
    'n': obj.n,
    'organization': obj.organization,
    'presencePenalty': obj.presencePenalty,
    'seed': obj.seed,
    'temperature': obj.temperature,
    'timeout': obj.timeout,
    'topP': obj.topP,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider of the model
 *
 * @schema ModelConfigSpecProvider
 */
export enum ModelConfigSpecProvider {
  /** Anthropic */
  ANTHROPIC = "Anthropic",
  /** OpenAI */
  OPEN_AI = "OpenAI",
  /** AzureOpenAI */
  AZURE_OPEN_AI = "AzureOpenAI",
  /** Ollama */
  OLLAMA = "Ollama",
  /** GeminiVertexAI */
  GEMINI_VERTEX_AI = "GeminiVertexAI",
  /** AnthropicVertexAI */
  ANTHROPIC_VERTEX_AI = "AnthropicVertexAI",
}


/**
 * Team is the Schema for the teams API.
 *
 * @schema Team
 */
export class Team extends ApiObject {
  /**
   * Returns the apiVersion and kind for "Team"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kagent.dev/v1alpha1',
    kind: 'Team',
  }

  /**
   * Renders a Kubernetes manifest for "Team".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: TeamProps = {}): any {
    return {
      ...Team.GVK,
      ...toJson_TeamProps(props),
    };
  }

  /**
   * Defines a "Team" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: TeamProps = {}) {
    super(scope, id, {
      ...Team.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...Team.GVK,
      ...toJson_TeamProps(resolved),
    };
  }
}

/**
 * Team is the Schema for the teams API.
 *
 * @schema Team
 */
export interface TeamProps {
  /**
   * @schema Team#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * TeamSpec defines the desired state of Team.
   *
   * @schema Team#spec
   */
  readonly spec?: TeamSpec;

}

/**
 * Converts an object of type 'TeamProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamProps(obj: TeamProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_TeamSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TeamSpec defines the desired state of Team.
 *
 * @schema TeamSpec
 */
export interface TeamSpec {
  /**
   * @schema TeamSpec#description
   */
  readonly description: string;

  /**
   * @schema TeamSpec#magenticOneTeamConfig
   */
  readonly magenticOneTeamConfig?: TeamSpecMagenticOneTeamConfig;

  /**
   * @schema TeamSpec#maxTurns
   */
  readonly maxTurns: number;

  /**
   * Can either be a reference to the name of a ModelConfig in the same namespace as the referencing Team, or a reference to the name of a ModelConfig in a different namespace in the form <namespace>/<name>
   *
   * @schema TeamSpec#modelConfig
   */
  readonly modelConfig: string;

  /**
   * Each Participant can either be a reference to the name of an Agent in the same namespace as the referencing Team, or a reference to the name of an Agent in a different namespace in the form <namespace>/<name>
   *
   * @schema TeamSpec#participants
   */
  readonly participants: string[];

  /**
   * @schema TeamSpec#roundRobinTeamConfig
   */
  readonly roundRobinTeamConfig?: any;

  /**
   * @schema TeamSpec#selectorTeamConfig
   */
  readonly selectorTeamConfig?: TeamSpecSelectorTeamConfig;

  /**
   * @schema TeamSpec#swarmTeamConfig
   */
  readonly swarmTeamConfig?: any;

  /**
   * @schema TeamSpec#terminationCondition
   */
  readonly terminationCondition: TeamSpecTerminationCondition;

}

/**
 * Converts an object of type 'TeamSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpec(obj: TeamSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'description': obj.description,
    'magenticOneTeamConfig': toJson_TeamSpecMagenticOneTeamConfig(obj.magenticOneTeamConfig),
    'maxTurns': obj.maxTurns,
    'modelConfig': obj.modelConfig,
    'participants': obj.participants?.map(y => y),
    'roundRobinTeamConfig': obj.roundRobinTeamConfig,
    'selectorTeamConfig': toJson_TeamSpecSelectorTeamConfig(obj.selectorTeamConfig),
    'swarmTeamConfig': obj.swarmTeamConfig,
    'terminationCondition': toJson_TeamSpecTerminationCondition(obj.terminationCondition),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecMagenticOneTeamConfig
 */
export interface TeamSpecMagenticOneTeamConfig {
  /**
   * @schema TeamSpecMagenticOneTeamConfig#finalAnswerPrompt
   */
  readonly finalAnswerPrompt: string;

  /**
   * @schema TeamSpecMagenticOneTeamConfig#maxStalls
   */
  readonly maxStalls: number;

}

/**
 * Converts an object of type 'TeamSpecMagenticOneTeamConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecMagenticOneTeamConfig(obj: TeamSpecMagenticOneTeamConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'finalAnswerPrompt': obj.finalAnswerPrompt,
    'maxStalls': obj.maxStalls,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecSelectorTeamConfig
 */
export interface TeamSpecSelectorTeamConfig {
  /**
   * @schema TeamSpecSelectorTeamConfig#selectorPrompt
   */
  readonly selectorPrompt: string;

}

/**
 * Converts an object of type 'TeamSpecSelectorTeamConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecSelectorTeamConfig(obj: TeamSpecSelectorTeamConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'selectorPrompt': obj.selectorPrompt,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationCondition
 */
export interface TeamSpecTerminationCondition {
  /**
   * @schema TeamSpecTerminationCondition#finalTextMessageTermination
   */
  readonly finalTextMessageTermination?: TeamSpecTerminationConditionFinalTextMessageTermination;

  /**
   * ONEOF: maxMessageTermination, textMentionTermination, orTermination
   *
   * @schema TeamSpecTerminationCondition#maxMessageTermination
   */
  readonly maxMessageTermination?: TeamSpecTerminationConditionMaxMessageTermination;

  /**
   * @schema TeamSpecTerminationCondition#orTermination
   */
  readonly orTermination?: TeamSpecTerminationConditionOrTermination;

  /**
   * @schema TeamSpecTerminationCondition#stopMessageTermination
   */
  readonly stopMessageTermination?: any;

  /**
   * @schema TeamSpecTerminationCondition#textMentionTermination
   */
  readonly textMentionTermination?: TeamSpecTerminationConditionTextMentionTermination;

  /**
   * @schema TeamSpecTerminationCondition#textMessageTermination
   */
  readonly textMessageTermination?: TeamSpecTerminationConditionTextMessageTermination;

}

/**
 * Converts an object of type 'TeamSpecTerminationCondition' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationCondition(obj: TeamSpecTerminationCondition | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'finalTextMessageTermination': toJson_TeamSpecTerminationConditionFinalTextMessageTermination(obj.finalTextMessageTermination),
    'maxMessageTermination': toJson_TeamSpecTerminationConditionMaxMessageTermination(obj.maxMessageTermination),
    'orTermination': toJson_TeamSpecTerminationConditionOrTermination(obj.orTermination),
    'stopMessageTermination': obj.stopMessageTermination,
    'textMentionTermination': toJson_TeamSpecTerminationConditionTextMentionTermination(obj.textMentionTermination),
    'textMessageTermination': toJson_TeamSpecTerminationConditionTextMessageTermination(obj.textMessageTermination),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionFinalTextMessageTermination
 */
export interface TeamSpecTerminationConditionFinalTextMessageTermination {
  /**
   * @schema TeamSpecTerminationConditionFinalTextMessageTermination#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionFinalTextMessageTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionFinalTextMessageTermination(obj: TeamSpecTerminationConditionFinalTextMessageTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ONEOF: maxMessageTermination, textMentionTermination, orTermination
 *
 * @schema TeamSpecTerminationConditionMaxMessageTermination
 */
export interface TeamSpecTerminationConditionMaxMessageTermination {
  /**
   * @schema TeamSpecTerminationConditionMaxMessageTermination#maxMessages
   */
  readonly maxMessages: number;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionMaxMessageTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionMaxMessageTermination(obj: TeamSpecTerminationConditionMaxMessageTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxMessages': obj.maxMessages,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionOrTermination
 */
export interface TeamSpecTerminationConditionOrTermination {
  /**
   * @schema TeamSpecTerminationConditionOrTermination#conditions
   */
  readonly conditions: TeamSpecTerminationConditionOrTerminationConditions[];

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionOrTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionOrTermination(obj: TeamSpecTerminationConditionOrTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_TeamSpecTerminationConditionOrTerminationConditions(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionTextMentionTermination
 */
export interface TeamSpecTerminationConditionTextMentionTermination {
  /**
   * @schema TeamSpecTerminationConditionTextMentionTermination#text
   */
  readonly text: string;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionTextMentionTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionTextMentionTermination(obj: TeamSpecTerminationConditionTextMentionTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionTextMessageTermination
 */
export interface TeamSpecTerminationConditionTextMessageTermination {
  /**
   * @schema TeamSpecTerminationConditionTextMessageTermination#source
   */
  readonly source: string;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionTextMessageTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionTextMessageTermination(obj: TeamSpecTerminationConditionTextMessageTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionOrTerminationConditions
 */
export interface TeamSpecTerminationConditionOrTerminationConditions {
  /**
   * @schema TeamSpecTerminationConditionOrTerminationConditions#maxMessageTermination
   */
  readonly maxMessageTermination?: TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination;

  /**
   * @schema TeamSpecTerminationConditionOrTerminationConditions#textMentionTermination
   */
  readonly textMentionTermination?: TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionOrTerminationConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionOrTerminationConditions(obj: TeamSpecTerminationConditionOrTerminationConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxMessageTermination': toJson_TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination(obj.maxMessageTermination),
    'textMentionTermination': toJson_TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination(obj.textMentionTermination),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination
 */
export interface TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination {
  /**
   * @schema TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination#maxMessages
   */
  readonly maxMessages: number;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination(obj: TeamSpecTerminationConditionOrTerminationConditionsMaxMessageTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxMessages': obj.maxMessages,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination
 */
export interface TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination {
  /**
   * @schema TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination#text
   */
  readonly text: string;

}

/**
 * Converts an object of type 'TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination(obj: TeamSpecTerminationConditionOrTerminationConditionsTextMentionTermination | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'text': obj.text,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ToolServer is the Schema for the toolservers API.
 *
 * @schema ToolServer
 */
export class ToolServer extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ToolServer"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'kagent.dev/v1alpha1',
    kind: 'ToolServer',
  }

  /**
   * Renders a Kubernetes manifest for "ToolServer".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ToolServerProps = {}): any {
    return {
      ...ToolServer.GVK,
      ...toJson_ToolServerProps(props),
    };
  }

  /**
   * Defines a "ToolServer" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ToolServerProps = {}) {
    super(scope, id, {
      ...ToolServer.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ToolServer.GVK,
      ...toJson_ToolServerProps(resolved),
    };
  }
}

/**
 * ToolServer is the Schema for the toolservers API.
 *
 * @schema ToolServer
 */
export interface ToolServerProps {
  /**
   * @schema ToolServer#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ToolServerSpec defines the desired state of ToolServer.
   *
   * @schema ToolServer#spec
   */
  readonly spec?: ToolServerSpec;

}

/**
 * Converts an object of type 'ToolServerProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerProps(obj: ToolServerProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ToolServerSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ToolServerSpec defines the desired state of ToolServer.
 *
 * @schema ToolServerSpec
 */
export interface ToolServerSpec {
  /**
   * @schema ToolServerSpec#config
   */
  readonly config: ToolServerSpecConfig;

  /**
   * @schema ToolServerSpec#description
   */
  readonly description: string;

}

/**
 * Converts an object of type 'ToolServerSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpec(obj: ToolServerSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'config': toJson_ToolServerSpecConfig(obj.config),
    'description': obj.description,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ToolServerSpecConfig
 */
export interface ToolServerSpecConfig {
  /**
   * @schema ToolServerSpecConfig#sse
   */
  readonly sse?: ToolServerSpecConfigSse;

  /**
   * @schema ToolServerSpecConfig#stdio
   */
  readonly stdio?: ToolServerSpecConfigStdio;

  /**
   * @schema ToolServerSpecConfig#streamableHttp
   */
  readonly streamableHttp?: ToolServerSpecConfigStreamableHttp;

}

/**
 * Converts an object of type 'ToolServerSpecConfig' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfig(obj: ToolServerSpecConfig | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'sse': toJson_ToolServerSpecConfigSse(obj.sse),
    'stdio': toJson_ToolServerSpecConfigStdio(obj.stdio),
    'streamableHttp': toJson_ToolServerSpecConfigStreamableHttp(obj.streamableHttp),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ToolServerSpecConfigSse
 */
export interface ToolServerSpecConfigSse {
  /**
   * @schema ToolServerSpecConfigSse#headers
   */
  readonly headers?: any;

  /**
   * @schema ToolServerSpecConfigSse#headersFrom
   */
  readonly headersFrom?: ToolServerSpecConfigSseHeadersFrom[];

  /**
   * @schema ToolServerSpecConfigSse#sseReadTimeout
   */
  readonly sseReadTimeout?: string;

  /**
   * @schema ToolServerSpecConfigSse#timeout
   */
  readonly timeout?: string;

  /**
   * @schema ToolServerSpecConfigSse#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ToolServerSpecConfigSse' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigSse(obj: ToolServerSpecConfigSse | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers,
    'headersFrom': obj.headersFrom?.map(y => toJson_ToolServerSpecConfigSseHeadersFrom(y)),
    'sseReadTimeout': obj.sseReadTimeout,
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ToolServerSpecConfigStdio
 */
export interface ToolServerSpecConfigStdio {
  /**
   * @schema ToolServerSpecConfigStdio#args
   */
  readonly args?: string[];

  /**
   * @schema ToolServerSpecConfigStdio#command
   */
  readonly command: string;

  /**
   * @schema ToolServerSpecConfigStdio#env
   */
  readonly env?: { [key: string]: string };

  /**
   * @schema ToolServerSpecConfigStdio#envFrom
   */
  readonly envFrom?: ToolServerSpecConfigStdioEnvFrom[];

  /**
   * Default value is 10 seconds
   *
   * @schema ToolServerSpecConfigStdio#readTimeoutSeconds
   */
  readonly readTimeoutSeconds?: number;

}

/**
 * Converts an object of type 'ToolServerSpecConfigStdio' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigStdio(obj: ToolServerSpecConfigStdio | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'args': obj.args?.map(y => y),
    'command': obj.command,
    'env': ((obj.env) === undefined) ? undefined : (Object.entries(obj.env).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'envFrom': obj.envFrom?.map(y => toJson_ToolServerSpecConfigStdioEnvFrom(y)),
    'readTimeoutSeconds': obj.readTimeoutSeconds,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ToolServerSpecConfigStreamableHttp
 */
export interface ToolServerSpecConfigStreamableHttp {
  /**
   * @schema ToolServerSpecConfigStreamableHttp#headers
   */
  readonly headers?: any;

  /**
   * @schema ToolServerSpecConfigStreamableHttp#headersFrom
   */
  readonly headersFrom?: ToolServerSpecConfigStreamableHttpHeadersFrom[];

  /**
   * @schema ToolServerSpecConfigStreamableHttp#sseReadTimeout
   */
  readonly sseReadTimeout?: string;

  /**
   * @schema ToolServerSpecConfigStreamableHttp#terminateOnClose
   */
  readonly terminateOnClose?: boolean;

  /**
   * @schema ToolServerSpecConfigStreamableHttp#timeout
   */
  readonly timeout?: string;

  /**
   * @schema ToolServerSpecConfigStreamableHttp#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ToolServerSpecConfigStreamableHttp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigStreamableHttp(obj: ToolServerSpecConfigStreamableHttp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'headers': obj.headers,
    'headersFrom': obj.headersFrom?.map(y => toJson_ToolServerSpecConfigStreamableHttpHeadersFrom(y)),
    'sseReadTimeout': obj.sseReadTimeout,
    'terminateOnClose': obj.terminateOnClose,
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueRef represents a configuration value
 *
 * @schema ToolServerSpecConfigSseHeadersFrom
 */
export interface ToolServerSpecConfigSseHeadersFrom {
  /**
   * @schema ToolServerSpecConfigSseHeadersFrom#name
   */
  readonly name: string;

  /**
   * @schema ToolServerSpecConfigSseHeadersFrom#value
   */
  readonly value?: string;

  /**
   * ValueSource defines a source for configuration values from a Secret or ConfigMap
   *
   * @schema ToolServerSpecConfigSseHeadersFrom#valueFrom
   */
  readonly valueFrom?: ToolServerSpecConfigSseHeadersFromValueFrom;

}

/**
 * Converts an object of type 'ToolServerSpecConfigSseHeadersFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigSseHeadersFrom(obj: ToolServerSpecConfigSseHeadersFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ToolServerSpecConfigSseHeadersFromValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueRef represents a configuration value
 *
 * @schema ToolServerSpecConfigStdioEnvFrom
 */
export interface ToolServerSpecConfigStdioEnvFrom {
  /**
   * @schema ToolServerSpecConfigStdioEnvFrom#name
   */
  readonly name: string;

  /**
   * @schema ToolServerSpecConfigStdioEnvFrom#value
   */
  readonly value?: string;

  /**
   * ValueSource defines a source for configuration values from a Secret or ConfigMap
   *
   * @schema ToolServerSpecConfigStdioEnvFrom#valueFrom
   */
  readonly valueFrom?: ToolServerSpecConfigStdioEnvFromValueFrom;

}

/**
 * Converts an object of type 'ToolServerSpecConfigStdioEnvFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigStdioEnvFrom(obj: ToolServerSpecConfigStdioEnvFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ToolServerSpecConfigStdioEnvFromValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueRef represents a configuration value
 *
 * @schema ToolServerSpecConfigStreamableHttpHeadersFrom
 */
export interface ToolServerSpecConfigStreamableHttpHeadersFrom {
  /**
   * @schema ToolServerSpecConfigStreamableHttpHeadersFrom#name
   */
  readonly name: string;

  /**
   * @schema ToolServerSpecConfigStreamableHttpHeadersFrom#value
   */
  readonly value?: string;

  /**
   * ValueSource defines a source for configuration values from a Secret or ConfigMap
   *
   * @schema ToolServerSpecConfigStreamableHttpHeadersFrom#valueFrom
   */
  readonly valueFrom?: ToolServerSpecConfigStreamableHttpHeadersFromValueFrom;

}

/**
 * Converts an object of type 'ToolServerSpecConfigStreamableHttpHeadersFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigStreamableHttpHeadersFrom(obj: ToolServerSpecConfigStreamableHttpHeadersFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'value': obj.value,
    'valueFrom': toJson_ToolServerSpecConfigStreamableHttpHeadersFromValueFrom(obj.valueFrom),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueSource defines a source for configuration values from a Secret or ConfigMap
 *
 * @schema ToolServerSpecConfigSseHeadersFromValueFrom
 */
export interface ToolServerSpecConfigSseHeadersFromValueFrom {
  /**
   * @schema ToolServerSpecConfigSseHeadersFromValueFrom#key
   */
  readonly key: string;

  /**
   * @schema ToolServerSpecConfigSseHeadersFromValueFrom#type
   */
  readonly type: ToolServerSpecConfigSseHeadersFromValueFromType;

  /**
   * The reference to the ConfigMap or Secret. Can either be a reference to a resource in the same namespace,
   * or a reference to a resource in a different namespace in the form "namespace/name".
   * If namespace is not provided, the default namespace is used.
   *
   * @schema ToolServerSpecConfigSseHeadersFromValueFrom#valueRef
   */
  readonly valueRef?: string;

}

/**
 * Converts an object of type 'ToolServerSpecConfigSseHeadersFromValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigSseHeadersFromValueFrom(obj: ToolServerSpecConfigSseHeadersFromValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'valueRef': obj.valueRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueSource defines a source for configuration values from a Secret or ConfigMap
 *
 * @schema ToolServerSpecConfigStdioEnvFromValueFrom
 */
export interface ToolServerSpecConfigStdioEnvFromValueFrom {
  /**
   * @schema ToolServerSpecConfigStdioEnvFromValueFrom#key
   */
  readonly key: string;

  /**
   * @schema ToolServerSpecConfigStdioEnvFromValueFrom#type
   */
  readonly type: ToolServerSpecConfigStdioEnvFromValueFromType;

  /**
   * The reference to the ConfigMap or Secret. Can either be a reference to a resource in the same namespace,
   * or a reference to a resource in a different namespace in the form "namespace/name".
   * If namespace is not provided, the default namespace is used.
   *
   * @schema ToolServerSpecConfigStdioEnvFromValueFrom#valueRef
   */
  readonly valueRef?: string;

}

/**
 * Converts an object of type 'ToolServerSpecConfigStdioEnvFromValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigStdioEnvFromValueFrom(obj: ToolServerSpecConfigStdioEnvFromValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'valueRef': obj.valueRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ValueSource defines a source for configuration values from a Secret or ConfigMap
 *
 * @schema ToolServerSpecConfigStreamableHttpHeadersFromValueFrom
 */
export interface ToolServerSpecConfigStreamableHttpHeadersFromValueFrom {
  /**
   * @schema ToolServerSpecConfigStreamableHttpHeadersFromValueFrom#key
   */
  readonly key: string;

  /**
   * @schema ToolServerSpecConfigStreamableHttpHeadersFromValueFrom#type
   */
  readonly type: ToolServerSpecConfigStreamableHttpHeadersFromValueFromType;

  /**
   * The reference to the ConfigMap or Secret. Can either be a reference to a resource in the same namespace,
   * or a reference to a resource in a different namespace in the form "namespace/name".
   * If namespace is not provided, the default namespace is used.
   *
   * @schema ToolServerSpecConfigStreamableHttpHeadersFromValueFrom#valueRef
   */
  readonly valueRef?: string;

}

/**
 * Converts an object of type 'ToolServerSpecConfigStreamableHttpHeadersFromValueFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ToolServerSpecConfigStreamableHttpHeadersFromValueFrom(obj: ToolServerSpecConfigStreamableHttpHeadersFromValueFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'type': obj.type,
    'valueRef': obj.valueRef,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ToolServerSpecConfigSseHeadersFromValueFromType
 */
export enum ToolServerSpecConfigSseHeadersFromValueFromType {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * @schema ToolServerSpecConfigStdioEnvFromValueFromType
 */
export enum ToolServerSpecConfigStdioEnvFromValueFromType {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

/**
 * @schema ToolServerSpecConfigStreamableHttpHeadersFromValueFromType
 */
export enum ToolServerSpecConfigStreamableHttpHeadersFromValueFromType {
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
  /** Secret */
  SECRET = "Secret",
}

