// generated by cdk8s
import { ApiObject, ApiObjectMetadata, GroupVersionKind } from 'cdk8s';
import { Construct } from 'constructs';


/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStore
 */
export class ClusterSecretStore extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSecretStore"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1alpha1',
    kind: 'ClusterSecretStore',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSecretStore".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSecretStoreProps = {}): any {
    return {
      ...ClusterSecretStore.GVK,
      ...toJson_ClusterSecretStoreProps(props),
    };
  }

  /**
   * Defines a "ClusterSecretStore" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSecretStoreProps = {}) {
    super(scope, id, {
      ...ClusterSecretStore.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSecretStore.GVK,
      ...toJson_ClusterSecretStoreProps(resolved),
    };
  }
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStore
 */
export interface ClusterSecretStoreProps {
  /**
   * @schema ClusterSecretStore#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema ClusterSecretStore#spec
   */
  readonly spec?: ClusterSecretStoreSpec;

}

/**
 * Converts an object of type 'ClusterSecretStoreProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreProps(obj: ClusterSecretStoreProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSecretStoreSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema ClusterSecretStoreSpec
 */
export interface ClusterSecretStoreSpec {
  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema ClusterSecretStoreSpec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema ClusterSecretStoreSpec#provider
   */
  readonly provider: ClusterSecretStoreSpecProvider;

  /**
   * Used to configure http retries if failed
   *
   * @schema ClusterSecretStoreSpec#retrySettings
   */
  readonly retrySettings?: ClusterSecretStoreSpecRetrySettings;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpec(obj: ClusterSecretStoreSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'controller': obj.controller,
    'provider': toJson_ClusterSecretStoreSpecProvider(obj.provider),
    'retrySettings': toJson_ClusterSecretStoreSpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema ClusterSecretStoreSpecProvider
 */
export interface ClusterSecretStoreSpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#akeyless
   */
  readonly akeyless?: ClusterSecretStoreSpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#alibaba
   */
  readonly alibaba?: ClusterSecretStoreSpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#aws
   */
  readonly aws?: ClusterSecretStoreSpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#azurekv
   */
  readonly azurekv?: ClusterSecretStoreSpecProviderAzurekv;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema ClusterSecretStoreSpecProvider#fake
   */
  readonly fake?: ClusterSecretStoreSpecProviderFake;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema ClusterSecretStoreSpecProvider#gcpsm
   */
  readonly gcpsm?: ClusterSecretStoreSpecProviderGcpsm;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema ClusterSecretStoreSpecProvider#gitlab
   */
  readonly gitlab?: ClusterSecretStoreSpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema ClusterSecretStoreSpecProvider#ibm
   */
  readonly ibm?: ClusterSecretStoreSpecProviderIbm;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema ClusterSecretStoreSpecProvider#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreSpecProviderKubernetes;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema ClusterSecretStoreSpecProvider#oracle
   */
  readonly oracle?: ClusterSecretStoreSpecProviderOracle;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema ClusterSecretStoreSpecProvider#vault
   */
  readonly vault?: ClusterSecretStoreSpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema ClusterSecretStoreSpecProvider#webhook
   */
  readonly webhook?: ClusterSecretStoreSpecProviderWebhook;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema ClusterSecretStoreSpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: ClusterSecretStoreSpecProviderYandexlockbox;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProvider(obj: ClusterSecretStoreSpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeyless': toJson_ClusterSecretStoreSpecProviderAkeyless(obj.akeyless),
    'alibaba': toJson_ClusterSecretStoreSpecProviderAlibaba(obj.alibaba),
    'aws': toJson_ClusterSecretStoreSpecProviderAws(obj.aws),
    'azurekv': toJson_ClusterSecretStoreSpecProviderAzurekv(obj.azurekv),
    'fake': toJson_ClusterSecretStoreSpecProviderFake(obj.fake),
    'gcpsm': toJson_ClusterSecretStoreSpecProviderGcpsm(obj.gcpsm),
    'gitlab': toJson_ClusterSecretStoreSpecProviderGitlab(obj.gitlab),
    'ibm': toJson_ClusterSecretStoreSpecProviderIbm(obj.ibm),
    'kubernetes': toJson_ClusterSecretStoreSpecProviderKubernetes(obj.kubernetes),
    'oracle': toJson_ClusterSecretStoreSpecProviderOracle(obj.oracle),
    'vault': toJson_ClusterSecretStoreSpecProviderVault(obj.vault),
    'webhook': toJson_ClusterSecretStoreSpecProviderWebhook(obj.webhook),
    'yandexlockbox': toJson_ClusterSecretStoreSpecProviderYandexlockbox(obj.yandexlockbox),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema ClusterSecretStoreSpecRetrySettings
 */
export interface ClusterSecretStoreSpecRetrySettings {
  /**
   * @schema ClusterSecretStoreSpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema ClusterSecretStoreSpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecRetrySettings(obj: ClusterSecretStoreSpecRetrySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetries': obj.maxRetries,
    'retryInterval': obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderAkeyless
 */
export interface ClusterSecretStoreSpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema ClusterSecretStoreSpecProviderAkeyless#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderAkeylessCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeyless(obj: ClusterSecretStoreSpecProviderAkeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeylessGWApiURL': obj.akeylessGwApiUrl,
    'authSecretRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(obj.authSecretRef),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderAkeylessCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderAlibaba
 */
export interface ClusterSecretStoreSpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreSpecProviderAlibaba#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema ClusterSecretStoreSpecProviderAlibaba#regionID
   */
  readonly regionId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibaba(obj: ClusterSecretStoreSpecProviderAlibaba | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderAlibabaAuth(obj.auth),
    'regionID': obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderAws
 */
export interface ClusterSecretStoreSpecProviderAws {
  /**
   * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema ClusterSecretStoreSpecProviderAws#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderAwsAuth;

  /**
   * AWS Region to be used for the provider
   *
   * @schema ClusterSecretStoreSpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the SecretManager provider will assume
   *
   * @schema ClusterSecretStoreSpecProviderAws#role
   */
  readonly role?: string;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema ClusterSecretStoreSpecProviderAws#service
   */
  readonly service: ClusterSecretStoreSpecProviderAwsService;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAws(obj: ClusterSecretStoreSpecProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderAwsAuth(obj.auth),
    'region': obj.region,
    'role': obj.role,
    'service': obj.service,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderAzurekv
 */
export interface ClusterSecretStoreSpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#authType
   */
  readonly authType?: ClusterSecretStoreSpecProviderAzurekvAuthType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekv(obj: ClusterSecretStoreSpecProviderAzurekv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(obj.authSecretRef),
    'authType': obj.authType,
    'identityId': obj.identityId,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(obj.serviceAccountRef),
    'tenantId': obj.tenantId,
    'vaultUrl': obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema ClusterSecretStoreSpecProviderFake
 */
export interface ClusterSecretStoreSpecProviderFake {
  /**
   * @schema ClusterSecretStoreSpecProviderFake#data
   */
  readonly data: ClusterSecretStoreSpecProviderFakeData[];

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFake(obj: ClusterSecretStoreSpecProviderFake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterSecretStoreSpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema ClusterSecretStoreSpecProviderGcpsm
 */
export interface ClusterSecretStoreSpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderGcpsmAuth;

  /**
   * ProjectID project where secret is located
   *
   * @schema ClusterSecretStoreSpecProviderGcpsm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsm(obj: ClusterSecretStoreSpecProviderGcpsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderGcpsmAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema ClusterSecretStoreSpecProviderGitlab
 */
export interface ClusterSecretStoreSpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderGitlabAuth;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema ClusterSecretStoreSpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema ClusterSecretStoreSpecProviderGitlab#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlab(obj: ClusterSecretStoreSpecProviderGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderGitlabAuth(obj.auth),
    'projectID': obj.projectId,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema ClusterSecretStoreSpecProviderIbm
 */
export interface ClusterSecretStoreSpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema ClusterSecretStoreSpecProviderIbm#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema ClusterSecretStoreSpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbm(obj: ClusterSecretStoreSpecProviderIbm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderIbmAuth(obj.auth),
    'serviceUrl': obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema ClusterSecretStoreSpecProviderKubernetes
 */
export interface ClusterSecretStoreSpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderKubernetesAuth;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetes#server
   */
  readonly server?: ClusterSecretStoreSpecProviderKubernetesServer;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetes(obj: ClusterSecretStoreSpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderKubernetesAuth(obj.auth),
    'remoteNamespace': obj.remoteNamespace,
    'server': toJson_ClusterSecretStoreSpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema ClusterSecretStoreSpecProviderOracle
 */
export interface ClusterSecretStoreSpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#auth
   */
  readonly auth?: ClusterSecretStoreSpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID. Required for PushSecret
   *
   * @schema ClusterSecretStoreSpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
   *
   * @schema ClusterSecretStoreSpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#principalType
   */
  readonly principalType?: ClusterSecretStoreSpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracle#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracle(obj: ClusterSecretStoreSpecProviderOracle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderOracleAuth(obj.auth),
    'compartment': obj.compartment,
    'encryptionKey': obj.encryptionKey,
    'principalType': obj.principalType,
    'region': obj.region,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderOracleServiceAccountRef(obj.serviceAccountRef),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema ClusterSecretStoreSpecProviderVault
 */
export interface ClusterSecretStoreSpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema ClusterSecretStoreSpecProviderVault#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderVault#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema ClusterSecretStoreSpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema ClusterSecretStoreSpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema ClusterSecretStoreSpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema ClusterSecretStoreSpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema ClusterSecretStoreSpecProviderVault#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema ClusterSecretStoreSpecProviderVault#version
   */
  readonly version?: ClusterSecretStoreSpecProviderVaultVersion;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVault(obj: ClusterSecretStoreSpecProviderVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreSpecProviderVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderVaultCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema ClusterSecretStoreSpecProviderWebhook
 */
export interface ClusterSecretStoreSpecProviderWebhook {
  /**
   * Body
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#result
   */
  readonly result: ClusterSecretStoreSpecProviderWebhookResult;

  /**
   * Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#secrets
   */
  readonly secrets?: ClusterSecretStoreSpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema ClusterSecretStoreSpecProviderWebhook#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhook(obj: ClusterSecretStoreSpecProviderWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderWebhookCaProvider(obj.caProvider),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'method': obj.method,
    'result': toJson_ClusterSecretStoreSpecProviderWebhookResult(obj.result),
    'secrets': obj.secrets?.map(y => toJson_ClusterSecretStoreSpecProviderWebhookSecrets(y)),
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockbox
 */
export interface ClusterSecretStoreSpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#auth
   */
  readonly auth: ClusterSecretStoreSpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderYandexlockboxCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockbox(obj: ClusterSecretStoreSpecProviderYandexlockbox | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreSpecProviderYandexlockboxAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details to authenticate with Akeyless.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesAuth': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(obj.kubernetesAuth),
    'secretRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider
 */
export interface ClusterSecretStoreSpecProviderAkeylessCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderAkeylessCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessCaProvider(obj: ClusterSecretStoreSpecProviderAkeylessCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuth
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: ClusterSecretStoreSpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuth(obj: ClusterSecretStoreSpecProviderAlibabaAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rrsa': toJson_ClusterSecretStoreSpecProviderAlibabaAuthRrsa(obj.rrsa),
    'secretRef': toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuth
 */
export interface ClusterSecretStoreSpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuth(obj: ClusterSecretStoreSpecProviderAwsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_ClusterSecretStoreSpecProviderAwsAuthJwt(obj.jwt),
    'secretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema ClusterSecretStoreSpecProviderAwsService
 */
export enum ClusterSecretStoreSpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRef(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthType
 */
export enum ClusterSecretStoreSpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvServiceAccountRef(obj: ClusterSecretStoreSpecProviderAzurekvServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderFakeData
 */
export interface ClusterSecretStoreSpecProviderFakeData {
  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#value
   */
  readonly value?: string;

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#valueMap
   */
  readonly valueMap?: { [key: string]: string };

  /**
   * @schema ClusterSecretStoreSpecProviderFakeData#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderFakeData(obj: ClusterSecretStoreSpecProviderFakeData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
    'valueMap': ((obj.valueMap) === undefined) ? undefined : (Object.entries(obj.valueMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuth
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuth(obj: ClusterSecretStoreSpecProviderGcpsmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema ClusterSecretStoreSpecProviderGitlabAuth
 */
export interface ClusterSecretStoreSpecProviderGitlabAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderGitlabAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuth(obj: ClusterSecretStoreSpecProviderGitlabAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretRef': toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuth
 */
export interface ClusterSecretStoreSpecProviderIbmAuth {
  /**
   * @schema ClusterSecretStoreSpecProviderIbmAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderIbmAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuth(obj: ClusterSecretStoreSpecProviderIbmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuth
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#cert
   */
  readonly cert?: ClusterSecretStoreSpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuth#token
   */
  readonly token?: ClusterSecretStoreSpecProviderKubernetesAuthToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuth(obj: ClusterSecretStoreSpecProviderKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_ClusterSecretStoreSpecProviderKubernetesAuthCert(obj.cert),
    'serviceAccount': toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(obj.serviceAccount),
    'token': toJson_ClusterSecretStoreSpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServer
 */
export interface ClusterSecretStoreSpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: ClusterSecretStoreSpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServer#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesServer(obj: ClusterSecretStoreSpecProviderKubernetesServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreSpecProviderKubernetesServerCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, instance principal is used. Optionally, the authenticating principal type and/or user data may be supplied for the use of workload identity and user principal.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuth
 */
export interface ClusterSecretStoreSpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuth#user
   */
  readonly user: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuth(obj: ClusterSecretStoreSpecProviderOracleAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRef(obj.secretRef),
    'tenancy': obj.tenancy,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
 *
 * @schema ClusterSecretStoreSpecProviderOraclePrincipalType
 */
export enum ClusterSecretStoreSpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleServiceAccountRef(obj: ClusterSecretStoreSpecProviderOracleServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuth
 */
export interface ClusterSecretStoreSpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#appRole
   */
  readonly appRole?: ClusterSecretStoreSpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#cert
   */
  readonly cert?: ClusterSecretStoreSpecProviderVaultAuthCert;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreSpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreSpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#ldap
   */
  readonly ldap?: ClusterSecretStoreSpecProviderVaultAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuth(obj: ClusterSecretStoreSpecProviderVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_ClusterSecretStoreSpecProviderVaultAuthAppRole(obj.appRole),
    'cert': toJson_ClusterSecretStoreSpecProviderVaultAuthCert(obj.cert),
    'jwt': toJson_ClusterSecretStoreSpecProviderVaultAuthJwt(obj.jwt),
    'kubernetes': toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetes(obj.kubernetes),
    'ldap': toJson_ClusterSecretStoreSpecProviderVaultAuthLdap(obj.ldap),
    'tokenSecretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(obj.tokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderVaultCaProvider
 */
export interface ClusterSecretStoreSpecProviderVaultCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderVaultCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderVaultCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultCaProvider(obj: ClusterSecretStoreSpecProviderVaultCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema ClusterSecretStoreSpecProviderVaultVersion
 */
export enum ClusterSecretStoreSpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderWebhookCaProvider
 */
export interface ClusterSecretStoreSpecProviderWebhookCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderWebhookCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderWebhookCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookCaProvider(obj: ClusterSecretStoreSpecProviderWebhookCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Result formatting
 *
 * @schema ClusterSecretStoreSpecProviderWebhookResult
 */
export interface ClusterSecretStoreSpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema ClusterSecretStoreSpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookResult(obj: ClusterSecretStoreSpecProviderWebhookResult | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderWebhookSecrets
 */
export interface ClusterSecretStoreSpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookSecrets(obj: ClusterSecretStoreSpecProviderWebhookSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxAuth
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxAuth(obj: ClusterSecretStoreSpecProviderYandexlockboxAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProvider
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProvider(obj: ClusterSecretStoreSpecProviderYandexlockboxCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': obj.accessId,
    'k8sConfName': obj.k8SConfName,
    'secretRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Secret that contains the details to authenticate with Akeyless.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj.accessId),
    'accessType': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj.accessType),
    'accessTypeParam': toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj.accessTypeParam),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessCaProviderType
 */
export enum ClusterSecretStoreSpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthRrsa {
  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthRrsa(obj: ClusterSecretStoreSpecProviderAlibabaAuthRrsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidcProviderArn': obj.oidcProviderArn,
    'oidcTokenFilePath': obj.oidcTokenFilePath,
    'roleArn': obj.roleArn,
    'sessionName': obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRef(obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthJwt
 */
export interface ClusterSecretStoreSpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthJwt(obj: ClusterSecretStoreSpecProviderAwsAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret(obj: ClusterSecretStoreSpecProviderAzurekvAuthSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRef(obj: ClusterSecretStoreSpecProviderGcpsmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity(obj: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRef(obj: ClusterSecretStoreSpecProviderGitlabAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRef(obj: ClusterSecretStoreSpecProviderIbmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretApiKeySecretRef': toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj.secretApiKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCert(obj: ClusterSecretStoreSpecProviderKubernetesAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(obj.clientCert),
    'clientKey': toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(obj.clientKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount(obj: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccount': toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(obj.serviceAccount),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * use static token to authenticate with
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthToken
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthToken(obj: ClusterSecretStoreSpecProviderKubernetesAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': toJson_ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(obj.bearerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider
 */
export interface ClusterSecretStoreSpecProviderKubernetesServerCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProvider#type
   */
  readonly type: ClusterSecretStoreSpecProviderKubernetesServerCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesServerCaProvider(obj: ClusterSecretStoreSpecProviderKubernetesServerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRef(obj: ClusterSecretStoreSpecProviderOracleAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fingerprint': toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(obj.fingerprint),
    'privatekey': toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(obj.privatekey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId: string;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRole(obj: ClusterSecretStoreSpecProviderVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCert
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreSpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCert(obj: ClusterSecretStoreSpecProviderVaultAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreSpecProviderVaultAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwt
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwt(obj: ClusterSecretStoreSpecProviderVaultAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetes(obj: ClusterSecretStoreSpecProviderVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthLdap
 */
export interface ClusterSecretStoreSpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthLdap(obj: ClusterSecretStoreSpecProviderVaultAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderVaultCaProviderType
 */
export enum ClusterSecretStoreSpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderWebhookCaProviderType
 */
export enum ClusterSecretStoreSpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef
 */
export interface ClusterSecretStoreSpecProviderWebhookSecretsSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderWebhookSecretsSecretRef(obj: ClusterSecretStoreSpecProviderWebhookSecretsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreSpecProviderYandexlockboxAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef(obj: ClusterSecretStoreSpecProviderYandexlockboxCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj: ClusterSecretStoreSpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj: ClusterSecretStoreSpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef(obj: ClusterSecretStoreSpecProviderAwsAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreSpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreSpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj: ClusterSecretStoreSpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken(obj: ClusterSecretStoreSpecProviderGitlabAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj: ClusterSecretStoreSpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert(obj: ClusterSecretStoreSpecProviderKubernetesAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey(obj: ClusterSecretStoreSpecProviderKubernetesAuthCertClientKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount(obj: ClusterSecretStoreSpecProviderKubernetesAuthServiceAccountServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken
 */
export interface ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken(obj: ClusterSecretStoreSpecProviderKubernetesAuthTokenBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreSpecProviderKubernetesServerCaProviderType
 */
export enum ClusterSecretStoreSpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint(obj: ClusterSecretStoreSpecProviderOracleAuthSecretRefFingerprint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey
 */
export interface ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey(obj: ClusterSecretStoreSpecProviderOracleAuthSecretRefPrivatekey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCertClientCert(obj: ClusterSecretStoreSpecProviderVaultAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthCertSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified.
   *
   * @default a single audience `vault` it not specified.
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef(obj: ClusterSecretStoreSpecProviderVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef(obj: ClusterSecretStoreSpecProviderVaultAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: ClusterSecretStoreSpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStoreV1Beta1
 */
export class ClusterSecretStoreV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ClusterSecretStoreV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'ClusterSecretStore',
  }

  /**
   * Renders a Kubernetes manifest for "ClusterSecretStoreV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ClusterSecretStoreV1Beta1Props = {}): any {
    return {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...toJson_ClusterSecretStoreV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ClusterSecretStoreV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ClusterSecretStoreV1Beta1Props = {}) {
    super(scope, id, {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ClusterSecretStoreV1Beta1.GVK,
      ...toJson_ClusterSecretStoreV1Beta1Props(resolved),
    };
  }
}

/**
 * ClusterSecretStore represents a secure external location for storing secrets, which can be referenced as part of `storeRef` fields.
 *
 * @schema ClusterSecretStoreV1Beta1
 */
export interface ClusterSecretStoreV1Beta1Props {
  /**
   * @schema ClusterSecretStoreV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * SecretStoreSpec defines the desired state of SecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1#spec
   */
  readonly spec?: ClusterSecretStoreV1Beta1Spec;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1Props(obj: ClusterSecretStoreV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ClusterSecretStoreV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreSpec defines the desired state of SecretStore.
 *
 * @schema ClusterSecretStoreV1Beta1Spec
 */
export interface ClusterSecretStoreV1Beta1Spec {
  /**
   * Used to constraint a ClusterSecretStore to specific namespaces. Relevant only to ClusterSecretStore
   *
   * @schema ClusterSecretStoreV1Beta1Spec#conditions
   */
  readonly conditions?: ClusterSecretStoreV1Beta1SpecConditions[];

  /**
   * Used to select the correct ESO controller (think: ingress.ingressClassName) The ESO controller is instantiated with a specific controller name and filters ES based on this property
   *
   * @schema ClusterSecretStoreV1Beta1Spec#controller
   */
  readonly controller?: string;

  /**
   * Used to configure the provider. Only one provider may be set
   *
   * @schema ClusterSecretStoreV1Beta1Spec#provider
   */
  readonly provider: ClusterSecretStoreV1Beta1SpecProvider;

  /**
   * Used to configure store refresh interval in seconds. Empty or 0 will default to the controller config.
   *
   * @schema ClusterSecretStoreV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: number;

  /**
   * Used to configure http retries if failed
   *
   * @schema ClusterSecretStoreV1Beta1Spec#retrySettings
   */
  readonly retrySettings?: ClusterSecretStoreV1Beta1SpecRetrySettings;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1Spec(obj: ClusterSecretStoreV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conditions': obj.conditions?.map(y => toJson_ClusterSecretStoreV1Beta1SpecConditions(y)),
    'controller': obj.controller,
    'provider': toJson_ClusterSecretStoreV1Beta1SpecProvider(obj.provider),
    'refreshInterval': obj.refreshInterval,
    'retrySettings': toJson_ClusterSecretStoreV1Beta1SpecRetrySettings(obj.retrySettings),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClusterSecretStoreCondition describes a condition by which to choose namespaces to process ExternalSecrets in for a ClusterSecretStore instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditions
 */
export interface ClusterSecretStoreV1Beta1SpecConditions {
  /**
   * Choose namespace using a labelSelector
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaceSelector
   */
  readonly namespaceSelector?: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector;

  /**
   * Choose namespaces by name
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditions#namespaces
   */
  readonly namespaces?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditions(obj: ClusterSecretStoreV1Beta1SpecConditions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'namespaceSelector': toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(obj.namespaceSelector),
    'namespaces': obj.namespaces?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure the provider. Only one provider may be set
 *
 * @schema ClusterSecretStoreV1Beta1SpecProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProvider {
  /**
   * Akeyless configures this store to sync secrets using Akeyless Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#akeyless
   */
  readonly akeyless?: ClusterSecretStoreV1Beta1SpecProviderAkeyless;

  /**
   * Alibaba configures this store to sync secrets using Alibaba Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#alibaba
   */
  readonly alibaba?: ClusterSecretStoreV1Beta1SpecProviderAlibaba;

  /**
   * AWS configures this store to sync secrets using AWS Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#aws
   */
  readonly aws?: ClusterSecretStoreV1Beta1SpecProviderAws;

  /**
   * AzureKV configures this store to sync secrets using Azure Key Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#azurekv
   */
  readonly azurekv?: ClusterSecretStoreV1Beta1SpecProviderAzurekv;

  /**
   * Conjur configures this store to sync secrets using conjur provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#conjur
   */
  readonly conjur?: ClusterSecretStoreV1Beta1SpecProviderConjur;

  /**
   * Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#delinea
   */
  readonly delinea?: ClusterSecretStoreV1Beta1SpecProviderDelinea;

  /**
   * Doppler configures this store to sync secrets using the Doppler provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#doppler
   */
  readonly doppler?: ClusterSecretStoreV1Beta1SpecProviderDoppler;

  /**
   * Fake configures a store with static key/value pairs
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#fake
   */
  readonly fake?: ClusterSecretStoreV1Beta1SpecProviderFake;

  /**
   * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#gcpsm
   */
  readonly gcpsm?: ClusterSecretStoreV1Beta1SpecProviderGcpsm;

  /**
   * GitLab configures this store to sync secrets using GitLab Variables provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#gitlab
   */
  readonly gitlab?: ClusterSecretStoreV1Beta1SpecProviderGitlab;

  /**
   * IBM configures this store to sync secrets using IBM Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#ibm
   */
  readonly ibm?: ClusterSecretStoreV1Beta1SpecProviderIbm;

  /**
   * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#keepersecurity
   */
  readonly keepersecurity?: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity;

  /**
   * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreV1Beta1SpecProviderKubernetes;

  /**
   * OnePassword configures this store to sync secrets using the 1Password Cloud provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#onepassword
   */
  readonly onepassword?: ClusterSecretStoreV1Beta1SpecProviderOnepassword;

  /**
   * Oracle configures this store to sync secrets using Oracle Vault provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#oracle
   */
  readonly oracle?: ClusterSecretStoreV1Beta1SpecProviderOracle;

  /**
   * Scaleway
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#scaleway
   */
  readonly scaleway?: ClusterSecretStoreV1Beta1SpecProviderScaleway;

  /**
   * Senhasegura configures this store to sync secrets using senhasegura provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#senhasegura
   */
  readonly senhasegura?: ClusterSecretStoreV1Beta1SpecProviderSenhasegura;

  /**
   * Vault configures this store to sync secrets using Hashi provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#vault
   */
  readonly vault?: ClusterSecretStoreV1Beta1SpecProviderVault;

  /**
   * Webhook configures this store to sync secrets using a generic templated webhook
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#webhook
   */
  readonly webhook?: ClusterSecretStoreV1Beta1SpecProviderWebhook;

  /**
   * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#yandexcertificatemanager
   */
  readonly yandexcertificatemanager?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager;

  /**
   * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProvider#yandexlockbox
   */
  readonly yandexlockbox?: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProvider(obj: ClusterSecretStoreV1Beta1SpecProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeyless': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeyless(obj.akeyless),
    'alibaba': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibaba(obj.alibaba),
    'aws': toJson_ClusterSecretStoreV1Beta1SpecProviderAws(obj.aws),
    'azurekv': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekv(obj.azurekv),
    'conjur': toJson_ClusterSecretStoreV1Beta1SpecProviderConjur(obj.conjur),
    'delinea': toJson_ClusterSecretStoreV1Beta1SpecProviderDelinea(obj.delinea),
    'doppler': toJson_ClusterSecretStoreV1Beta1SpecProviderDoppler(obj.doppler),
    'fake': toJson_ClusterSecretStoreV1Beta1SpecProviderFake(obj.fake),
    'gcpsm': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsm(obj.gcpsm),
    'gitlab': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlab(obj.gitlab),
    'ibm': toJson_ClusterSecretStoreV1Beta1SpecProviderIbm(obj.ibm),
    'keepersecurity': toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(obj.keepersecurity),
    'kubernetes': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetes(obj.kubernetes),
    'onepassword': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepassword(obj.onepassword),
    'oracle': toJson_ClusterSecretStoreV1Beta1SpecProviderOracle(obj.oracle),
    'scaleway': toJson_ClusterSecretStoreV1Beta1SpecProviderScaleway(obj.scaleway),
    'senhasegura': toJson_ClusterSecretStoreV1Beta1SpecProviderSenhasegura(obj.senhasegura),
    'vault': toJson_ClusterSecretStoreV1Beta1SpecProviderVault(obj.vault),
    'webhook': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhook(obj.webhook),
    'yandexcertificatemanager': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(obj.yandexcertificatemanager),
    'yandexlockbox': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(obj.yandexlockbox),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to configure http retries if failed
 *
 * @schema ClusterSecretStoreV1Beta1SpecRetrySettings
 */
export interface ClusterSecretStoreV1Beta1SpecRetrySettings {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecRetrySettings#maxRetries
   */
  readonly maxRetries?: number;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecRetrySettings#retryInterval
   */
  readonly retryInterval?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecRetrySettings' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecRetrySettings(obj: ClusterSecretStoreV1Beta1SpecRetrySettings | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'maxRetries': obj.maxRetries,
    'retryInterval': obj.retryInterval,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Choose namespace using a labelSelector
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector
 */
export interface ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector {
  /**
   * matchExpressions is a list of label selector requirements. The requirements are ANDed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchExpressions
   */
  readonly matchExpressions?: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions[];

  /**
   * matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector#matchLabels
   */
  readonly matchLabels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector(obj: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelector | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'matchExpressions': obj.matchExpressions?.map(y => toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(y)),
    'matchLabels': ((obj.matchLabels) === undefined) ? undefined : (Object.entries(obj.matchLabels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Akeyless configures this store to sync secrets using Akeyless Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeyless {
  /**
   * Akeyless GW API Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#akeylessGWApiURL
   */
  readonly akeylessGwApiUrl: string;

  /**
   * Auth configures how the operator authenticates with Akeyless.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#authSecretRef
   */
  readonly authSecretRef: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef;

  /**
   * PEM/base64 encoded CA bundle used to validate Akeyless Gateway certificate. Only used if the AkeylessGWApiURL URL is using HTTPS protocol. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeyless#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeyless' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeyless(obj: ClusterSecretStoreV1Beta1SpecProviderAkeyless | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'akeylessGWApiURL': obj.akeylessGwApiUrl,
    'authSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(obj.authSecretRef),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Alibaba configures this store to sync secrets using Alibaba Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibaba {
  /**
   * AlibabaAuth contains a secretRef for credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth;

  /**
   * Alibaba Region to be used for the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibaba#regionID
   */
  readonly regionId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibaba' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibaba(obj: ClusterSecretStoreV1Beta1SpecProviderAlibaba | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(obj.auth),
    'regionID': obj.regionId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWS configures this store to sync secrets using AWS Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAws
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAws {
  /**
   * AdditionalRoles is a chained list of Role ARNs which the provider will sequentially assume before assuming the Role
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#additionalRoles
   */
  readonly additionalRoles?: string[];

  /**
   * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderAwsAuth;

  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#externalID
   */
  readonly externalId?: string;

  /**
   * AWS Region to be used for the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#region
   */
  readonly region: string;

  /**
   * Role is a Role ARN which the provider will assume
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#role
   */
  readonly role?: string;

  /**
   * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#secretsManager
   */
  readonly secretsManager?: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager;

  /**
   * Service defines which service should be used to fetch the secrets
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#service
   */
  readonly service: ClusterSecretStoreV1Beta1SpecProviderAwsService;

  /**
   * AWS STS assume role session tags
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#sessionTags
   */
  readonly sessionTags?: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags[];

  /**
   * AWS STS assume role transitive session tags. Required when multiple rules are used with the provider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAws#transitiveTagKeys
   */
  readonly transitiveTagKeys?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAws' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAws(obj: ClusterSecretStoreV1Beta1SpecProviderAws | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'additionalRoles': obj.additionalRoles?.map(y => y),
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuth(obj.auth),
    'externalID': obj.externalId,
    'region': obj.region,
    'role': obj.role,
    'secretsManager': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(obj.secretsManager),
    'service': obj.service,
    'sessionTags': obj.sessionTags?.map(y => toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(y)),
    'transitiveTagKeys': obj.transitiveTagKeys?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AzureKV configures this store to sync secrets using Azure Key Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekv {
  /**
   * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#authSecretRef
   */
  readonly authSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef;

  /**
   * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#authType
   */
  readonly authType?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType;

  /**
   * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#environmentType
   */
  readonly environmentType?: ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType;

  /**
   * If multiple Managed Identity is assigned to the pod, you can select the one to be used
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#identityId
   */
  readonly identityId?: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef;

  /**
   * TenantID configures the Azure Tenant to send requests to. Required for ServicePrincipal auth type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#tenantId
   */
  readonly tenantId?: string;

  /**
   * Vault Url from which the secrets to be fetched from.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekv#vaultUrl
   */
  readonly vaultUrl: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekv' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekv(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekv | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(obj.authSecretRef),
    'authType': obj.authType,
    'environmentType': obj.environmentType,
    'identityId': obj.identityId,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(obj.serviceAccountRef),
    'tenantId': obj.tenantId,
    'vaultUrl': obj.vaultUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Conjur configures this store to sync secrets using conjur provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjur
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjur {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderConjurAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#caBundle
   */
  readonly caBundle?: string;

  /**
   * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjur#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjur' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjur(obj: ClusterSecretStoreV1Beta1SpecProviderConjur | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Delinea DevOps Secrets Vault https://docs.delinea.com/online-help/products/devops-secrets-vault/current
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelinea {
  /**
   * ClientID is the non-secret part of the credential.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#clientId
   */
  readonly clientId: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId;

  /**
   * ClientSecret is the secret part of the credential.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#clientSecret
   */
  readonly clientSecret: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret;

  /**
   * Tenant is the chosen hostname / site name.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#tenant
   */
  readonly tenant: string;

  /**
   * TLD is based on the server location that was chosen during provisioning. If unset, defaults to "com".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#tld
   */
  readonly tld?: string;

  /**
   * URLTemplate If unset, defaults to "https://%s.secretsvaultcloud.%s/v1/%s%s".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelinea#urlTemplate
   */
  readonly urlTemplate?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelinea' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelinea(obj: ClusterSecretStoreV1Beta1SpecProviderDelinea | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(obj.clientSecret),
    'tenant': obj.tenant,
    'tld': obj.tld,
    'urlTemplate': obj.urlTemplate,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Doppler configures this store to sync secrets using the Doppler provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDoppler {
  /**
   * Auth configures how the Operator authenticates with the Doppler API
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth;

  /**
   * Doppler config (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#config
   */
  readonly config?: string;

  /**
   * Format enables the downloading of secrets as a file (string)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#format
   */
  readonly format?: ClusterSecretStoreV1Beta1SpecProviderDopplerFormat;

  /**
   * Environment variable compatible name transforms that change secret names to a different format
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#nameTransformer
   */
  readonly nameTransformer?: ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer;

  /**
   * Doppler project (required if not using a Service Token)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDoppler#project
   */
  readonly project?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDoppler' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDoppler(obj: ClusterSecretStoreV1Beta1SpecProviderDoppler | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(obj.auth),
    'config': obj.config,
    'format': obj.format,
    'nameTransformer': obj.nameTransformer,
    'project': obj.project,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fake configures a store with static key/value pairs
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderFake
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFake {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFake#data
   */
  readonly data: ClusterSecretStoreV1Beta1SpecProviderFakeData[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFake' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFake(obj: ClusterSecretStoreV1Beta1SpecProviderFake | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ClusterSecretStoreV1Beta1SpecProviderFakeData(y)),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GCPSM configures this store to sync secrets using Google Cloud Platform Secret Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsm {
  /**
   * Auth defines the information necessary to authenticate against GCP
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth;

  /**
   * ProjectID project where secret is located
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsm#projectID
   */
  readonly projectId?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsm(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(obj.auth),
    'projectID': obj.projectId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GitLab configures this store to sync secrets using GitLab Variables provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlab {
  /**
   * Auth configures how secret-manager authenticates with a GitLab instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth;

  /**
   * Environment environment_scope of gitlab CI/CD variables (Please see https://docs.gitlab.com/ee/ci/environments/#create-a-static-environment on how to create environments)
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#environment
   */
  readonly environment?: string;

  /**
   * GroupIDs specify, which gitlab groups to pull secrets from. Group secrets are read from left to right followed by the project variables.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#groupIDs
   */
  readonly groupIDs?: string[];

  /**
   * InheritFromGroups specifies whether parent groups should be discovered and checked for secrets.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#inheritFromGroups
   */
  readonly inheritFromGroups?: boolean;

  /**
   * ProjectID specifies a project where secrets are located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#projectID
   */
  readonly projectId?: string;

  /**
   * URL configures the GitLab instance URL. Defaults to https://gitlab.com/.
   *
   * @default https://gitlab.com/.
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlab#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlab' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlab(obj: ClusterSecretStoreV1Beta1SpecProviderGitlab | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(obj.auth),
    'environment': obj.environment,
    'groupIDs': obj.groupIDs?.map(y => y),
    'inheritFromGroups': obj.inheritFromGroups,
    'projectID': obj.projectId,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM configures this store to sync secrets using IBM Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbm
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbm {
  /**
   * Auth configures how secret-manager authenticates with the IBM secrets manager.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbm#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderIbmAuth;

  /**
   * ServiceURL is the Endpoint URL that is specific to the Secrets Manager service instance
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbm#serviceUrl
   */
  readonly serviceUrl?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbm' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbm(obj: ClusterSecretStoreV1Beta1SpecProviderIbm | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuth(obj.auth),
    'serviceUrl': obj.serviceUrl,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * KeeperSecurity configures this store to sync secrets using the KeeperSecurity provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKeepersecurity {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#authRef
   */
  readonly authRef: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurity#folderID
   */
  readonly folderId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKeepersecurity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurity(obj: ClusterSecretStoreV1Beta1SpecProviderKeepersecurity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authRef': toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(obj.authRef),
    'folderID': obj.folderId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes configures this store to sync secrets using a Kubernetes cluster provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetes {
  /**
   * Auth configures how secret-manager authenticates with a Kubernetes instance.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth;

  /**
   * Remote namespace to fetch the secrets from
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#remoteNamespace
   */
  readonly remoteNamespace?: string;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetes#server
   */
  readonly server?: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetes(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(obj.auth),
    'remoteNamespace': obj.remoteNamespace,
    'server': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(obj.server),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePassword configures this store to sync secrets using the 1Password Cloud provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepassword {
  /**
   * Auth defines the information necessary to authenticate against OnePassword Connect Server
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth;

  /**
   * ConnectHost defines the OnePassword Connect Server to connect to
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#connectHost
   */
  readonly connectHost: string;

  /**
   * Vaults defines which OnePassword vaults to search in which order
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepassword#vaults
   */
  readonly vaults: { [key: string]: number };

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepassword' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepassword(obj: ClusterSecretStoreV1Beta1SpecProviderOnepassword | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(obj.auth),
    'connectHost': obj.connectHost,
    'vaults': ((obj.vaults) === undefined) ? undefined : (Object.entries(obj.vaults).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Oracle configures this store to sync secrets using Oracle Vault provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracle
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracle {
  /**
   * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#auth
   */
  readonly auth?: ClusterSecretStoreV1Beta1SpecProviderOracleAuth;

  /**
   * Compartment is the vault compartment OCID. Required for PushSecret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#compartment
   */
  readonly compartment?: string;

  /**
   * EncryptionKey is the OCID of the encryption key within the vault. Required for PushSecret
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#encryptionKey
   */
  readonly encryptionKey?: string;

  /**
   * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#principalType
   */
  readonly principalType?: ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType;

  /**
   * Region is the region where vault is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#region
   */
  readonly region: string;

  /**
   * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef;

  /**
   * Vault is the vault's OCID of the specific vault where secret is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracle#vault
   */
  readonly vault: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracle' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracle(obj: ClusterSecretStoreV1Beta1SpecProviderOracle | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuth(obj.auth),
    'compartment': obj.compartment,
    'encryptionKey': obj.encryptionKey,
    'principalType': obj.principalType,
    'region': obj.region,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(obj.serviceAccountRef),
    'vault': obj.vault,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Scaleway
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScaleway {
  /**
   * AccessKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#accessKey
   */
  readonly accessKey: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey;

  /**
   * APIURL is the url of the api to use. Defaults to https://api.scaleway.com
   *
   * @default https://api.scaleway.com
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#apiUrl
   */
  readonly apiUrl?: string;

  /**
   * ProjectID is the id of your project, which you can find in the console: https://console.scaleway.com/project/settings
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#projectId
   */
  readonly projectId: string;

  /**
   * Region where your secrets are located: https://developers.scaleway.com/en/quickstart/#region-and-zone
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#region
   */
  readonly region: string;

  /**
   * SecretKey is the non-secret part of the api key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScaleway#secretKey
   */
  readonly secretKey: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScaleway' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScaleway(obj: ClusterSecretStoreV1Beta1SpecProviderScaleway | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKey': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(obj.accessKey),
    'apiUrl': obj.apiUrl,
    'projectId': obj.projectId,
    'region': obj.region,
    'secretKey': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(obj.secretKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Senhasegura configures this store to sync secrets using senhasegura provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhasegura {
  /**
   * Auth defines parameters to authenticate in senhasegura
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth;

  /**
   * IgnoreSslCertificate defines if SSL certificate must be ignored
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#ignoreSslCertificate
   */
  readonly ignoreSslCertificate?: boolean;

  /**
   * Module defines which senhasegura module should be used to get secrets
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#module
   */
  readonly module: string;

  /**
   * URL of senhasegura
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhasegura#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhasegura' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhasegura(obj: ClusterSecretStoreV1Beta1SpecProviderSenhasegura | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj.auth),
    'ignoreSslCertificate': obj.ignoreSslCertificate,
    'module': obj.module,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Vault configures this store to sync secrets using Hashi provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVault
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVault {
  /**
   * Auth configures how secret-manager authenticates with the Vault server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderVaultAuth;

  /**
   * PEM encoded CA bundle used to validate Vault server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate Vault server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider;

  /**
   * ForwardInconsistent tells Vault to forward read-after-write requests to the Vault leader instead of simply retrying within a loop. This can increase performance if the option is enabled serverside. https://www.vaultproject.io/docs/configuration/replication#allow_forwarding_via_header
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#forwardInconsistent
   */
  readonly forwardInconsistent?: boolean;

  /**
   * Name of the vault namespace. Namespaces is a set of features within Vault Enterprise that allows Vault environments to support Secure Multi-tenancy. e.g: "ns1". More about namespaces can be found here https://www.vaultproject.io/docs/enterprise/namespaces
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#namespace
   */
  readonly namespace?: string;

  /**
   * Path is the mount path of the Vault KV backend endpoint, e.g: "secret". The v2 KV secret engine version specific "/data" path suffix for fetching secrets from Vault is optional and will be appended if not present in specified path.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#path
   */
  readonly path?: string;

  /**
   * ReadYourWrites ensures isolated read-after-write semantics by providing discovered cluster replication states in each request. More information about eventual consistency in Vault can be found here https://www.vaultproject.io/docs/enterprise/consistency
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#readYourWrites
   */
  readonly readYourWrites?: boolean;

  /**
   * Server is the connection address for the Vault server, e.g: "https://vault.example.com:8200".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#server
   */
  readonly server: string;

  /**
   * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVault#version
   */
  readonly version?: ClusterSecretStoreV1Beta1SpecProviderVaultVersion;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVault' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVault(obj: ClusterSecretStoreV1Beta1SpecProviderVault | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuth(obj.auth),
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(obj.caProvider),
    'forwardInconsistent': obj.forwardInconsistent,
    'namespace': obj.namespace,
    'path': obj.path,
    'readYourWrites': obj.readYourWrites,
    'server': obj.server,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Webhook configures this store to sync secrets using a generic templated webhook
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhook {
  /**
   * Body
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#body
   */
  readonly body?: string;

  /**
   * PEM encoded CA bundle used to validate webhook server certificate. Only used if the Server URL is using HTTPS protocol. This parameter is ignored for plain HTTP protocol connection. If not set the system root certificates are used to validate the TLS connection.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#caBundle
   */
  readonly caBundle?: string;

  /**
   * The provider for the CA bundle to use to validate webhook server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider;

  /**
   * Headers
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#headers
   */
  readonly headers?: { [key: string]: string };

  /**
   * Webhook Method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#method
   */
  readonly method?: string;

  /**
   * Result formatting
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#result
   */
  readonly result: ClusterSecretStoreV1Beta1SpecProviderWebhookResult;

  /**
   * Secrets to fill in templates These secrets will be passed to the templating function as key value pairs under the given name
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#secrets
   */
  readonly secrets?: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets[];

  /**
   * Timeout
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#timeout
   */
  readonly timeout?: string;

  /**
   * Webhook url to call
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhook#url
   */
  readonly url: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhook' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhook(obj: ClusterSecretStoreV1Beta1SpecProviderWebhook | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'body': obj.body,
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(obj.caProvider),
    'headers': ((obj.headers) === undefined) ? undefined : (Object.entries(obj.headers).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'method': obj.method,
    'result': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookResult(obj.result),
    'secrets': obj.secrets?.map(y => toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(y)),
    'timeout': obj.timeout,
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexCertificateManager configures this store to sync secrets using Yandex Certificate Manager provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Certificate Manager
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * YandexLockbox configures this store to sync secrets using Yandex Lockbox provider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockbox {
  /**
   * Yandex.Cloud API endpoint (e.g. 'api.cloud.yandex.net:443')
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#apiEndpoint
   */
  readonly apiEndpoint?: string;

  /**
   * Auth defines the information necessary to authenticate against Yandex Lockbox
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#auth
   */
  readonly auth: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth;

  /**
   * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockbox#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockbox' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockbox(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockbox | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiEndpoint': obj.apiEndpoint,
    'auth': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj.auth),
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(obj.caProvider),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A label selector requirement is a selector that contains values, a key, and an operator that relates the key and values.
 *
 * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions
 */
export interface ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions {
  /**
   * key is the label key that the selector applies to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#key
   */
  readonly key: string;

  /**
   * operator represents a key's relationship to a set of values. Valid operators are In, NotIn, Exists and DoesNotExist.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#operator
   */
  readonly operator: string;

  /**
   * values is an array of string values. If the operator is In or NotIn, the values array must be non-empty. If the operator is Exists or DoesNotExist, the values array must be empty. This array is replaced during a strategic merge patch.
   *
   * @schema ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions#values
   */
  readonly values?: string[];

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions(obj: ClusterSecretStoreV1Beta1SpecConditionsNamespaceSelectorMatchExpressions | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'operator': obj.operator,
    'values': obj.values?.map(y => y),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Akeyless.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef {
  /**
   * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#kubernetesAuth
   */
  readonly kubernetesAuth?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth;

  /**
   * Reference to a Secret that contains the details to authenticate with Akeyless.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesAuth': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(obj.kubernetesAuth),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Akeyless Gateway certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuth contains a secretRef for credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth {
  /**
   * Authenticate against Alibaba using RRSA.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#rrsa
   */
  readonly rrsa?: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa;

  /**
   * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'rrsa': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj.rrsa),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against AWS if not set aws sdk will infer credentials from your environment see: https://docs.aws.amazon.com/sdk-for-go/v1/developer-guide/configuring-sdk.html#specifying-credentials
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuth {
  /**
   * Authenticate against AWS using service account tokens.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt;

  /**
   * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuth(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(obj.jwt),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretsManager defines how the provider behaves when interacting with AWS SecretsManager
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager {
  /**
   * Specifies whether to delete the secret without any recovery window. You can't use both this parameter and RecoveryWindowInDays in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-ForceDeleteWithoutRecovery
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#forceDeleteWithoutRecovery
   */
  readonly forceDeleteWithoutRecovery?: boolean;

  /**
   * The number of days from 7 to 30 that Secrets Manager waits before permanently deleting the secret. You can't use both this parameter and ForceDeleteWithoutRecovery in the same call. If you don't use either, then by default Secrets Manager uses a 30 day recovery window. see: https://docs.aws.amazon.com/secretsmanager/latest/apireference/API_DeleteSecret.html#SecretsManager-DeleteSecret-request-RecoveryWindowInDays
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager#recoveryWindowInDays
   */
  readonly recoveryWindowInDays?: number;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager(obj: ClusterSecretStoreV1Beta1SpecProviderAwsSecretsManager | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'forceDeleteWithoutRecovery': obj.forceDeleteWithoutRecovery,
    'recoveryWindowInDays': obj.recoveryWindowInDays,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service defines which service should be used to fetch the secrets
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsService
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAwsService {
  /** SecretsManager */
  SECRETS_MANAGER = "SecretsManager",
  /** ParameterStore */
  PARAMETER_STORE = "ParameterStore",
}

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags#value
   */
  readonly value: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags(obj: ClusterSecretStoreV1Beta1SpecProviderAwsSessionTags | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the operator authenticates with Azure. Required for ServicePrincipal auth type.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef {
  /**
   * The Azure clientId of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientId
   */
  readonly clientId?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId;

  /**
   * The Azure ClientSecret of the service principle used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef#clientSecret
   */
  readonly clientSecret?: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(obj.clientId),
    'clientSecret': toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(obj.clientSecret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth type defines how to authenticate to the keyvault service. Valid values are: - "ServicePrincipal" (default): Using a service principal (tenantId, clientId, clientSecret) - "ManagedIdentity": Using Managed Identity assigned to the pod (see aad-pod-identity)
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthType {
  /** ServicePrincipal */
  SERVICE_PRINCIPAL = "ServicePrincipal",
  /** ManagedIdentity */
  MANAGED_IDENTITY = "ManagedIdentity",
  /** WorkloadIdentity */
  WORKLOAD_IDENTITY = "WorkloadIdentity",
}

/**
 * EnvironmentType specifies the Azure cloud environment endpoints to use for connecting and authenticating with Azure. By default it points to the public cloud AAD endpoint. The following endpoints are available, also see here: https://github.com/Azure/go-autorest/blob/main/autorest/azure/environments.go#L152 PublicCloud, USGovernmentCloud, ChinaCloud, GermanCloud
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAzurekvEnvironmentType {
  /** PublicCloud */
  PUBLIC_CLOUD = "PublicCloud",
  /** USGovernmentCloud */
  US_GOVERNMENT_CLOUD = "USGovernmentCloud",
  /** ChinaCloud */
  CHINA_CLOUD = "ChinaCloud",
  /** GermanCloud */
  GERMAN_CLOUD = "GermanCloud",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth#apikey
   */
  readonly apikey?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuth(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apikey': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(obj.apikey),
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(obj.jwt),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to provide custom certificate authority (CA) certificates for a secret store. The CAProvider points to a Secret or ConfigMap resource that contains a PEM-encoded certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderConjurCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientID is the non-secret part of the credential.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientId {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientId#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientId(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientSecret is the secret part of the credential.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how the Operator authenticates with the Doppler API
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Format enables the downloading of secrets as a file (string)
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerFormat
 */
export enum ClusterSecretStoreV1Beta1SpecProviderDopplerFormat {
  /** json */
  JSON = "json",
  /** dotnet-json */
  DOTNET_HYPHEN_JSON = "dotnet-json",
  /** env */
  ENV = "env",
  /** yaml */
  YAML = "yaml",
  /** docker */
  DOCKER = "docker",
}

/**
 * Environment variable compatible name transforms that change secret names to a different format
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer
 */
export enum ClusterSecretStoreV1Beta1SpecProviderDopplerNameTransformer {
  /** upper-camel */
  UPPER_HYPHEN_CAMEL = "upper-camel",
  /** camel */
  CAMEL = "camel",
  /** lower-snake */
  LOWER_HYPHEN_SNAKE = "lower-snake",
  /** tf-var */
  TF_HYPHEN_VAR = "tf-var",
  /** dotnet-env */
  DOTNET_HYPHEN_ENV = "dotnet-env",
  /** lower-kebab */
  LOWER_HYPHEN_KEBAB = "lower-kebab",
}

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData
 */
export interface ClusterSecretStoreV1Beta1SpecProviderFakeData {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#key
   */
  readonly key: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#value
   */
  readonly value?: string;

  /**
   * Deprecated: ValueMap is deprecated and is intended to be removed in the future, use the `value` field instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#valueMap
   */
  readonly valueMap?: { [key: string]: string };

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderFakeData#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderFakeData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderFakeData(obj: ClusterSecretStoreV1Beta1SpecProviderFakeData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'value': obj.value,
    'valueMap': ((obj.valueMap) === undefined) ? undefined : (Object.entries(obj.valueMap).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against GCP
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth#workloadIdentity
   */
  readonly workloadIdentity?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(obj.secretRef),
    'workloadIdentity': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(obj.workloadIdentity),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a GitLab instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuth#SecretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuth(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'SecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the IBM secrets manager.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuth {
  /**
   * IBM Container-based auth with IAM Trusted Profile.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth#containerAuth
   */
  readonly containerAuth?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuth(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'containerAuth': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(obj.containerAuth),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef(obj: ClusterSecretStoreV1Beta1SpecProviderKeepersecurityAuthRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with a Kubernetes instance.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth {
  /**
   * has both clientCert and clientKey as secretKeySelector
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#cert
   */
  readonly cert?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert;

  /**
   * points to a service account that should be used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#serviceAccount
   */
  readonly serviceAccount?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount;

  /**
   * use static token to authenticate with
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth#token
   */
  readonly token?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'cert': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj.cert),
    'serviceAccount': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(obj.serviceAccount),
    'token': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj.token),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * configures the Kubernetes server Address.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesServer {
  /**
   * CABundle is a base64-encoded CA certificate
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caBundle
   */
  readonly caBundle?: string;

  /**
   * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#caProvider
   */
  readonly caProvider?: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider;

  /**
   * configures the Kubernetes server Address.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServer#url
   */
  readonly url?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesServer' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServer(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesServer | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'caBundle': obj.caBundle,
    'caProvider': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(obj.caProvider),
    'url': obj.url,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against OnePassword Connect Server
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth {
  /**
   * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth(obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Oracle Vault. If empty, use the instance principal, otherwise the user credentials specified in Auth.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuth {
  /**
   * SecretRef to pass through sensitive information.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef;

  /**
   * Tenancy is the tenancy OCID where user is located.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#tenancy
   */
  readonly tenancy: string;

  /**
   * User is an access OCID specific to the account.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuth#user
   */
  readonly user: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuth(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(obj.secretRef),
    'tenancy': obj.tenancy,
    'user': obj.user,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of principal to use for authentication. If left blank, the Auth struct will determine the principal type. This optional field must be specified if using workload identity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderOraclePrincipalType {
  /** UserPrincipal */
  USER_PRINCIPAL = "UserPrincipal",
  /** InstancePrincipal */
  INSTANCE_PRINCIPAL = "InstancePrincipal",
  /** Workload */
  WORKLOAD = "Workload",
}

/**
 * ServiceAccountRef specified the service account that should be used when authenticating with WorkloadIdentity.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderOracleServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey(obj: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretKey is the non-secret part of the api key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey {
  /**
   * SecretRef references a key in a secret that will be used as value.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef;

  /**
   * Value can be specified directly to set a value without using a secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey#value
   */
  readonly value?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey(obj: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(obj.secretRef),
    'value': obj.value,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines parameters to authenticate in senhasegura
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientId
   */
  readonly clientId: string;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth#clientSecretSecretRef
   */
  readonly clientSecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth(obj: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientId': obj.clientId,
    'clientSecretSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(obj.clientSecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth configures how secret-manager authenticates with the Vault server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuth {
  /**
   * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#appRole
   */
  readonly appRole?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole;

  /**
   * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#cert
   */
  readonly cert?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert;

  /**
   * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#iam
   */
  readonly iam?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam;

  /**
   * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt;

  /**
   * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#kubernetes
   */
  readonly kubernetes?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes;

  /**
   * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#ldap
   */
  readonly ldap?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap;

  /**
   * TokenSecretRef authenticates with Vault by presenting a token.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#tokenSecretRef
   */
  readonly tokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef;

  /**
   * UserPass authenticates with Vault by passing username/password pair
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuth#userPass
   */
  readonly userPass?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuth(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'appRole': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj.appRole),
    'cert': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(obj.cert),
    'iam': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(obj.iam),
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(obj.jwt),
    'kubernetes': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(obj.kubernetes),
    'ldap': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(obj.ldap),
    'tokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(obj.tokenSecretRef),
    'userPass': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(obj.userPass),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Vault server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderVaultCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Version is the Vault KV secret engine version. This can be either "v1" or "v2". Version defaults to "v2".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultVersion
 */
export enum ClusterSecretStoreV1Beta1SpecProviderVaultVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * The provider for the CA bundle to use to validate webhook server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider {
  /**
   * The key the value inside of the provider type to use, only used with "Secret" type
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Result formatting
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookResult
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookResult {
  /**
   * Json path of return value
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookResult#jsonPath
   */
  readonly jsonPath?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookResult' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookResult(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookResult | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'jsonPath': obj.jsonPath,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets {
  /**
   * Name of this secret in templates
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#name
   */
  readonly name: string;

  /**
   * Secret ref to fill in credentials
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookSecrets | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'name': obj.name,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Certificate Manager
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Auth defines the information necessary to authenticate against Yandex Lockbox
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth {
  /**
   * The authorized key used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth#authorizedKeySecretRef
   */
  readonly authorizedKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'authorizedKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj.authorizedKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The provider for the CA bundle to use to validate Yandex.Cloud server certificate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider#certSecretRef
   */
  readonly certSecretRef?: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'certSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(obj.certSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Akeyless by passing the ServiceAccount token stored in the named Secret resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth {
  /**
   * the Akeyless Kubernetes auth-method access-id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#accessID
   */
  readonly accessId: string;

  /**
   * Kubernetes-auth configuration name in Akeyless-Gateway
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#k8sConfName
   */
  readonly k8SConfName: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': obj.accessId,
    'k8sConfName': obj.k8SConfName,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a Secret that contains the details to authenticate with Akeyless.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef {
  /**
   * The SecretAccessID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessID
   */
  readonly accessId?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessType
   */
  readonly accessType?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef#accessTypeParam
   */
  readonly accessTypeParam?: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessID': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj.accessId),
    'accessType': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj.accessType),
    'accessTypeParam': toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj.accessTypeParam),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderAkeylessCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Authenticate against Alibaba using RRSA.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcProviderArn
   */
  readonly oidcProviderArn: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#oidcTokenFilePath
   */
  readonly oidcTokenFilePath: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#roleArn
   */
  readonly roleArn: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa#sessionName
   */
  readonly sessionName: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthRrsa | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'oidcProviderArn': obj.oidcProviderArn,
    'oidcTokenFilePath': obj.oidcTokenFilePath,
    'roleArn': obj.roleArn,
    'sessionName': obj.sessionName,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AlibabaAuthSecretRef holds secret references for Alibaba credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The AccessKeySecret is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef#accessKeySecretSecretRef
   */
  readonly accessKeySecretSecretRef: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'accessKeySecretSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj.accessKeySecretSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Authenticate against AWS using service account tokens.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AWSAuthSecretRef holds secret references for AWS credentials both AccessKeyID and SecretAccessKey must be defined in order to properly authenticate.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure clientId of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The Azure ClientSecret of the service principle used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret(obj: ClusterSecretStoreV1Beta1SpecProviderAzurekvAuthSecretRefClientSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#account
   */
  readonly account: string;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#apiKeyRef
   */
  readonly apiKeyRef: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey#userRef
   */
  readonly userRef: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'apiKeyRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(obj.apiKeyRef),
    'userRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(obj.userRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#account
   */
  readonly account: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef;

  /**
   * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef;

  /**
   * The conjur authn jwt webservice id
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt#serviceID
   */
  readonly serviceId: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'account': obj.account,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(obj.serviceAccountRef),
    'serviceID': obj.serviceId,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderConjurCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDelineaClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef {
  /**
   * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef#dopplerToken
   */
  readonly dopplerToken: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'dopplerToken': toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(obj.dopplerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterLocation
   */
  readonly clusterLocation: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterName
   */
  readonly clusterName: string;

  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#clusterProjectID
   */
  readonly clusterProjectId?: string;

  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentity | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clusterLocation': obj.clusterLocation,
    'clusterName': obj.clusterName,
    'clusterProjectID': obj.clusterProjectId,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef {
  /**
   * AccessToken is used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef#accessToken
   */
  readonly accessToken?: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessToken': toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(obj.accessToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * IBM Container-based auth with IAM Trusted Profile.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth {
  /**
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#iamEndpoint
   */
  readonly iamEndpoint?: string;

  /**
   * the IBM Trusted Profile
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#profile
   */
  readonly profile: string;

  /**
   * Location the token is mounted on the pod
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth#tokenLocation
   */
  readonly tokenLocation?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthContainerAuth | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'iamEndpoint': obj.iamEndpoint,
    'profile': obj.profile,
    'tokenLocation': obj.tokenLocation,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef {
  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef#secretApiKeySecretRef
   */
  readonly secretApiKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'secretApiKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj.secretApiKeySecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * has both clientCert and clientKey as secretKeySelector
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert;

  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert#clientKey
   */
  readonly clientKey?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(obj.clientCert),
    'clientKey': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(obj.clientKey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * points to a service account that should be used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthServiceAccount | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * use static token to authenticate with
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken {
  /**
   * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken#bearerToken
   */
  readonly bearerToken?: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'bearerToken': toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(obj.bearerToken),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * see: https://external-secrets.io/v0.4.1/spec/#external-secrets.io/v1alpha1.CAProvider
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider {
  /**
   * The key where the CA certificate can be found in the Secret or ConfigMap.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#key
   */
  readonly key?: string;

  /**
   * The name of the object located at the provider type.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#name
   */
  readonly name: string;

  /**
   * The namespace the Provider type is in. Can only be defined when used in a ClusterSecretStore.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#namespace
   */
  readonly namespace?: string;

  /**
   * The type of provider to use such as "Secret", or "ConfigMap".
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider#type
   */
  readonly type: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProvider | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * OnePasswordAuthSecretRef holds secret references for 1Password credentials.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef {
  /**
   * The ConnectToken is used for authentication to a 1Password Connect Server.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef#connectTokenSecretRef
   */
  readonly connectTokenSecretRef: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'connectTokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj.connectTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to pass through sensitive information.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef {
  /**
   * Fingerprint is the fingerprint of the API private key.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#fingerprint
   */
  readonly fingerprint: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint;

  /**
   * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef#privatekey
   */
  readonly privatekey: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'fingerprint': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(obj.fingerprint),
    'privatekey': toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(obj.privatekey),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderScalewayAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef references a key in a secret that will be used as value.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderScalewaySecretKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderSenhaseguraAuthClientSecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AppRole authenticates with Vault using the App Role auth mechanism, with the role and secret stored in a Kubernetes Secret resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole {
  /**
   * Path where the App Role authentication backend is mounted in Vault, e.g: "approle"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#path
   */
  readonly path: string;

  /**
   * RoleID configured in the App Role authentication backend when setting up the authentication backend in Vault.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleId
   */
  readonly roleId?: string;

  /**
   * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#roleRef
   */
  readonly roleRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef;

  /**
   * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole#secretRef
   */
  readonly secretRef: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRole | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'roleId': obj.roleId,
    'roleRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(obj.roleRef),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Cert authenticates with TLS Certificates by passing client certificate, private key and ca certificate Cert authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert {
  /**
   * ClientCert is a certificate to authenticate using the Cert Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#clientCert
   */
  readonly clientCert?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert;

  /**
   * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'clientCert': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(obj.clientCert),
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Iam authenticates with vault by passing a special AWS request signed with AWS IAM credentials AWS IAM authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam {
  /**
   * AWS External ID set on assumed IAM roles
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#externalID
   */
  readonly externalId?: string;

  /**
   * Specify a service account with IRSA enabled
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#jwt
   */
  readonly jwt?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt;

  /**
   * Path where the AWS auth method is enabled in Vault, e.g: "aws"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#path
   */
  readonly path?: string;

  /**
   * AWS region
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#region
   */
  readonly region?: string;

  /**
   * This is the AWS role to be assumed before talking to vault
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#role
   */
  readonly role?: string;

  /**
   * Specify credentials in a Secret object
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef;

  /**
   * X-Vault-AWS-IAM-Server-ID is an additional header used by Vault IAM auth method to mitigate against different types of replay attacks. More details here: https://developer.hashicorp.com/vault/docs/auth/aws
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultAwsIamServerID
   */
  readonly vaultAwsIamServerId?: string;

  /**
   * Vault Role. In vault, a role describes an identity with a set of permissions, groups, or policies you want to attach a user of the secrets engine
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam#vaultRole
   */
  readonly vaultRole: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'externalID': obj.externalId,
    'jwt': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj.jwt),
    'path': obj.path,
    'region': obj.region,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(obj.secretRef),
    'vaultAwsIamServerID': obj.vaultAwsIamServerId,
    'vaultRole': obj.vaultRole,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Jwt authenticates with Vault by passing role and JWT token using the JWT/OIDC authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt {
  /**
   * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#kubernetesServiceAccountToken
   */
  readonly kubernetesServiceAccountToken?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken;

  /**
   * Path where the JWT authentication backend is mounted in Vault, e.g: "jwt"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#path
   */
  readonly path: string;

  /**
   * Role is a JWT role to authenticate using the JWT/OIDC Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#role
   */
  readonly role?: string;

  /**
   * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kubernetesServiceAccountToken': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj.kubernetesServiceAccountToken),
    'path': obj.path,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(obj.secretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Kubernetes authenticates with Vault by passing the ServiceAccount token stored in the named Secret resource to the Vault server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes {
  /**
   * Path where the Kubernetes authentication backend is mounted in Vault, e.g: "kubernetes"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#mountPath
   */
  readonly mountPath: string;

  /**
   * A required field containing the Vault Role to assume. A Role binds a Kubernetes ServiceAccount with a set of Vault policies.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#role
   */
  readonly role: string;

  /**
   * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef;

  /**
   * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetes | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'mountPath': obj.mountPath,
    'role': obj.role,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(obj.secretRef),
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Ldap authenticates with Vault by passing username/password pair using the LDAP authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap {
  /**
   * Path where the LDAP authentication backend is mounted in Vault, e.g: "ldap"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef;

  /**
   * Username is a LDAP user name used to authenticate using the LDAP Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * TokenSecretRef authenticates with Vault by presenting a token.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * UserPass authenticates with Vault by passing username/password pair
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass {
  /**
   * Path where the UserPassword authentication backend is mounted in Vault, e.g: "user"
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#path
   */
  readonly path: string;

  /**
   * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#secretRef
   */
  readonly secretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef;

  /**
   * Username is a user name used to authenticate using the UserPass Vault authentication method
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass#username
   */
  readonly username: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPass | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'path': obj.path,
    'secretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(obj.secretRef),
    'username': obj.username,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderVaultCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderWebhookCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * Secret ref to fill in credentials
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderWebhookSecretsSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexcertificatemanagerCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The authorized key used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxAuthAuthorizedKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderYandexlockboxCaProviderCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Akeyless. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Akeyless. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefKubernetesAuthServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessId | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessType | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam(obj: ClusterSecretStoreV1Beta1SpecProviderAkeylessAuthSecretRefSecretRefAccessTypeParam | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeySecret is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAlibabaAuthSecretRefAccessKeySecretSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderAwsAuthSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyApiKeyRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthApikeyUserRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Conjur using the JWT authentication method.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountRef specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderConjurAuthJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The DopplerToken is used for authentication. See https://docs.doppler.com/reference/api#authentication for auth token types. The Key attribute defaults to dopplerToken if not specified.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken(obj: ClusterSecretStoreV1Beta1SpecProviderDopplerAuthSecretRefDopplerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderGcpsmAuthWorkloadIdentityServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * AccessToken is used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken(obj: ClusterSecretStoreV1Beta1SpecProviderGitlabAuthSecretRefAccessToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderIbmAuthSecretRefSecretApiKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthCertClientKey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a specific 'key' within a Secret resource, In some instances, `key` is a required field.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken(obj: ClusterSecretStoreV1Beta1SpecProviderKubernetesAuthTokenBearerToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The type of provider to use such as "Secret", or "ConfigMap".
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType
 */
export enum ClusterSecretStoreV1Beta1SpecProviderKubernetesServerCaProviderType {
  /** Secret */
  SECRET = "Secret",
  /** ConfigMap */
  CONFIG_MAP = "ConfigMap",
}

/**
 * The ConnectToken is used for authentication to a 1Password Connect Server.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderOnepasswordAuthSecretRefConnectTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Fingerprint is the fingerprint of the API private key.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefFingerprint | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * PrivateKey is the user's API Signing Key in PEM format, used for authentication.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey
 */
export interface ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey(obj: ClusterSecretStoreV1Beta1SpecProviderOracleAuthSecretRefPrivatekey | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role ID used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role id.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleRoleRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Reference to a key in a Secret that contains the App Role secret used to authenticate with Vault. The `key` field must be specified and denotes which entry within the Secret resource is used as the app role secret.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthAppRoleSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ClientCert is a certificate to authenticate using the Cert Vault authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertClientCert | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing client private key to authenticate with Vault using the Cert authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthCertSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify a service account with IRSA enabled
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt {
  /**
   * A reference to a ServiceAccount resource.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt#serviceAccountRef
   */
  readonly serviceAccountRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwt | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Specify credentials in a Secret object
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef {
  /**
   * The AccessKeyID is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#accessKeyIDSecretRef
   */
  readonly accessKeyIdSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef;

  /**
   * The SecretAccessKey is used for authentication
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#secretAccessKeySecretRef
   */
  readonly secretAccessKeySecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef;

  /**
   * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef#sessionTokenSecretRef
   */
  readonly sessionTokenSecretRef?: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'accessKeyIDSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj.accessKeyIdSecretRef),
    'secretAccessKeySecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj.secretAccessKeySecretRef),
    'sessionTokenSecretRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj.sessionTokenSecretRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional ServiceAccountToken specifies the Kubernetes service account for which to request a token for with the `TokenRequest` API.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken {
  /**
   * Optional audiences field that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Defaults to a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   *
   * @default a single audience `vault` it not specified. Deprecated: use serviceAccountRef.Audiences instead
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#audiences
   */
  readonly audiences?: string[];

  /**
   * Optional expiration time in seconds that will be used to request a temporary Kubernetes service account token for the service account referenced by `serviceAccountRef`. Deprecated: this will be removed in the future. Defaults to 10 minutes.
   *
   * @default 10 minutes.
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#expirationSeconds
   */
  readonly expirationSeconds?: number;

  /**
   * Service account field containing the name of a kubernetes ServiceAccount.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken#serviceAccountRef
   */
  readonly serviceAccountRef: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountToken | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'expirationSeconds': obj.expirationSeconds,
    'serviceAccountRef': toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj.serviceAccountRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional SecretRef that refers to a key in a Secret resource containing JWT token to authenticate with Vault using the JWT/OIDC authentication method.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional secret field containing a Kubernetes ServiceAccount JWT used for authenticating with Vault. If a name is specified without a key, `token` is the default. If one is not specified, the one bound to the controller will be used.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Optional service account field containing the name of a kubernetes ServiceAccount. If the service account is specified, the service account secret token JWT will be used for authenticating with Vault. If the service account selector is not supplied, the secretRef will be used instead.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthKubernetesServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the LDAP user used to authenticate with Vault using the LDAP authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthLdapSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretRef to a key in a Secret resource containing password for the user used to authenticate with Vault using the UserPass authentication method
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthUserPassSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * A reference to a ServiceAccount resource.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamJwtServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The AccessKeyID is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefAccessKeyIdSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SecretAccessKey is used for authentication
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSecretAccessKeySecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * The SessionToken used for authentication This must be defined if AccessKeyID and SecretAccessKey are temporary credentials see: https://docs.aws.amazon.com/IAM/latest/UserGuide/id_credentials_temp_use-resources.html
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef {
  /**
   * The key of the entry in the Secret resource's `data` field to be used. Some instances of this field may be defaulted, in others it may be required.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#key
   */
  readonly key?: string;

  /**
   * The name of the Secret resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#name
   */
  readonly name?: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthIamSecretRefSessionTokenSecretRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Service account field containing the name of a kubernetes ServiceAccount.
 *
 * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef
 */
export interface ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef {
  /**
   * Audience specifies the `aud` claim for the service account token If the service account uses a well-known annotation for e.g. IRSA or GCP Workload Identity then this audiences will be appended to the list
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#audiences
   */
  readonly audiences?: string[];

  /**
   * The name of the ServiceAccount resource being referred to.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#name
   */
  readonly name: string;

  /**
   * Namespace of the resource being referred to. Ignored if referent is not cluster-scoped. cluster-scoped defaults to the namespace of the referent.
   *
   * @schema ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef#namespace
   */
  readonly namespace?: string;

}

/**
 * Converts an object of type 'ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef(obj: ClusterSecretStoreV1Beta1SpecProviderVaultAuthJwtKubernetesServiceAccountTokenServiceAccountRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'audiences': obj.audiences?.map(y => y),
    'name': obj.name,
    'namespace': obj.namespace,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export class ExternalSecret extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecret"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1alpha1',
    kind: 'ExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalSecret".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretProps = {}): any {
    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(props),
    };
  }

  /**
   * Defines a "ExternalSecret" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalSecretProps = {}) {
    super(scope, id, {
      ...ExternalSecret.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecret.GVK,
      ...toJson_ExternalSecretProps(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecret
 */
export interface ExternalSecretProps {
  /**
   * @schema ExternalSecret#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecret#spec
   */
  readonly spec?: ExternalSecretSpec;

}

/**
 * Converts an object of type 'ExternalSecretProps' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretProps(obj: ExternalSecretProps | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalSecretSpec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretSpec
 */
export interface ExternalSecretSpec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretSpec#data
   */
  readonly data?: ExternalSecretSpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretSpec#dataFrom
   */
  readonly dataFrom?: ExternalSecretSpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretSpec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretSpec#secretStoreRef
   */
  readonly secretStoreRef: ExternalSecretSpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretSpec#target
   */
  readonly target: ExternalSecretSpecTarget;

}

/**
 * Converts an object of type 'ExternalSecretSpec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpec(obj: ExternalSecretSpec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ExternalSecretSpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ExternalSecretSpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'secretStoreRef': toJson_ExternalSecretSpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ExternalSecretSpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretSpecData
 */
export interface ExternalSecretSpecData {
  /**
   * ExternalSecretDataRemoteRef defines Provider data location.
   *
   * @schema ExternalSecretSpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretSpecDataRemoteRef;

  /**
   * @schema ExternalSecretSpecData#secretKey
   */
  readonly secretKey: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecData(obj: ExternalSecretSpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ExternalSecretSpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretDataRemoteRef defines Provider data location.
 *
 * @schema ExternalSecretSpecDataFrom
 */
export interface ExternalSecretSpecDataFrom {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataFrom#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataFromConversionStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataFrom#key
   */
  readonly key: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataFrom#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataFrom#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataFrom(obj: ExternalSecretSpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'key': obj.key,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretSpecSecretStoreRef
 */
export interface ExternalSecretSpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretSpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretSpecSecretStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecSecretStoreRef(obj: ExternalSecretSpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretSpecTarget
 */
export interface ExternalSecretSpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ExternalSecretSpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretSpecTargetCreationPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretSpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretSpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretSpecTarget#template
   */
  readonly template?: ExternalSecretSpecTargetTemplate;

}

/**
 * Converts an object of type 'ExternalSecretSpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTarget(obj: ExternalSecretSpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ExternalSecretSpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretDataRemoteRef defines Provider data location.
 *
 * @schema ExternalSecretSpecDataRemoteRef
 */
export interface ExternalSecretSpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretSpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretSpecDataRemoteRefConversionStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretSpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretSpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecDataRemoteRef(obj: ExternalSecretSpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'key': obj.key,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataFromConversionStrategy
 */
export enum ExternalSecretSpecDataFromConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
 *
 * @default Owner'
 * @schema ExternalSecretSpecTargetCreationPolicy
 */
export enum ExternalSecretSpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretSpecTargetTemplate
 */
export interface ExternalSecretSpecTargetTemplate {
  /**
   * @schema ExternalSecretSpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretSpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ExternalSecretSpecTargetTemplateEngineVersion;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretSpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretSpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretSpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretSpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretSpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplate(obj: ExternalSecretSpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'metadata': toJson_ExternalSecretSpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretSpecDataRemoteRefConversionStrategy
 */
export enum ExternalSecretSpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
 *
 * @schema ExternalSecretSpecTargetTemplateEngineVersion
 */
export enum ExternalSecretSpecTargetTemplateEngineVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretSpecTargetTemplateMetadata
 */
export interface ExternalSecretSpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretSpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateMetadata(obj: ExternalSecretSpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretSpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretSpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretSpecTargetTemplateTemplateFromSecret;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFrom(obj: ExternalSecretSpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'secret': toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(obj.secret),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMap(obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretSpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecret(obj: ExternalSecretSpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems(obj: ExternalSecretSpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretSpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ExternalSecretSpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

}

/**
 * Converts an object of type 'ExternalSecretSpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretSpecTargetTemplateTemplateFromSecretItems(obj: ExternalSecretSpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */


/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export class ExternalSecretV1Beta1 extends ApiObject {
  /**
   * Returns the apiVersion and kind for "ExternalSecretV1Beta1"
   */
  public static readonly GVK: GroupVersionKind = {
    apiVersion: 'external-secrets.io/v1beta1',
    kind: 'ExternalSecret',
  }

  /**
   * Renders a Kubernetes manifest for "ExternalSecretV1Beta1".
   *
   * This can be used to inline resource manifests inside other objects (e.g. as templates).
   *
   * @param props initialization props
   */
  public static manifest(props: ExternalSecretV1Beta1Props = {}): any {
    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(props),
    };
  }

  /**
   * Defines a "ExternalSecretV1Beta1" API object
   * @param scope the scope in which to define this object
   * @param id a scope-local name for the object
   * @param props initialization props
   */
  public constructor(scope: Construct, id: string, props: ExternalSecretV1Beta1Props = {}) {
    super(scope, id, {
      ...ExternalSecretV1Beta1.GVK,
      ...props,
    });
  }

  /**
   * Renders the object to Kubernetes JSON.
   */
  public toJson(): any {
    const resolved = super.toJson();

    return {
      ...ExternalSecretV1Beta1.GVK,
      ...toJson_ExternalSecretV1Beta1Props(resolved),
    };
  }
}

/**
 * ExternalSecret is the Schema for the external-secrets API.
 *
 * @schema ExternalSecretV1Beta1
 */
export interface ExternalSecretV1Beta1Props {
  /**
   * @schema ExternalSecretV1Beta1#metadata
   */
  readonly metadata?: ApiObjectMetadata;

  /**
   * ExternalSecretSpec defines the desired state of ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1#spec
   */
  readonly spec?: ExternalSecretV1Beta1Spec;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Props' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1Props(obj: ExternalSecretV1Beta1Props | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'metadata': obj.metadata,
    'spec': toJson_ExternalSecretV1Beta1Spec(obj.spec),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretSpec defines the desired state of ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1Spec
 */
export interface ExternalSecretV1Beta1Spec {
  /**
   * Data defines the connection between the Kubernetes Secret keys and the Provider data
   *
   * @schema ExternalSecretV1Beta1Spec#data
   */
  readonly data?: ExternalSecretV1Beta1SpecData[];

  /**
   * DataFrom is used to fetch all properties from a specific Provider data If multiple entries are specified, the Secret keys are merged in the specified order
   *
   * @schema ExternalSecretV1Beta1Spec#dataFrom
   */
  readonly dataFrom?: ExternalSecretV1Beta1SpecDataFrom[];

  /**
   * RefreshInterval is the amount of time before the values are read again from the SecretStore provider Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h" May be set to zero to fetch and create it once. Defaults to 1h.
   *
   * @default 1h.
   * @schema ExternalSecretV1Beta1Spec#refreshInterval
   */
  readonly refreshInterval?: string;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1Spec#secretStoreRef
   */
  readonly secretStoreRef?: ExternalSecretV1Beta1SpecSecretStoreRef;

  /**
   * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
   *
   * @schema ExternalSecretV1Beta1Spec#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTarget;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1Spec' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1Spec(obj: ExternalSecretV1Beta1Spec | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': obj.data?.map(y => toJson_ExternalSecretV1Beta1SpecData(y)),
    'dataFrom': obj.dataFrom?.map(y => toJson_ExternalSecretV1Beta1SpecDataFrom(y)),
    'refreshInterval': obj.refreshInterval,
    'secretStoreRef': toJson_ExternalSecretV1Beta1SpecSecretStoreRef(obj.secretStoreRef),
    'target': toJson_ExternalSecretV1Beta1SpecTarget(obj.target),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretData defines the connection between the Kubernetes Secret key (spec.data.<key>) and the Provider data.
 *
 * @schema ExternalSecretV1Beta1SpecData
 */
export interface ExternalSecretV1Beta1SpecData {
  /**
   * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
   *
   * @schema ExternalSecretV1Beta1SpecData#remoteRef
   */
  readonly remoteRef: ExternalSecretV1Beta1SpecDataRemoteRef;

  /**
   * SecretKey defines the key in which the controller stores the value. This is the key in the Kind=Secret
   *
   * @schema ExternalSecretV1Beta1SpecData#secretKey
   */
  readonly secretKey: string;

  /**
   * SourceRef allows you to override the source from which the value will pulled from.
   *
   * @schema ExternalSecretV1Beta1SpecData#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecData' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecData(obj: ExternalSecretV1Beta1SpecData | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'remoteRef': toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj.remoteRef),
    'secretKey': obj.secretKey,
    'sourceRef': toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFrom
 */
export interface ExternalSecretV1Beta1SpecDataFrom {
  /**
   * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#extract
   */
  readonly extract?: ExternalSecretV1Beta1SpecDataFromExtract;

  /**
   * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#find
   */
  readonly find?: ExternalSecretV1Beta1SpecDataFromFind;

  /**
   * Used to rewrite secret Keys after getting them from the secret Provider Multiple Rewrite operations can be provided. They are applied in a layered order (first to last)
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#rewrite
   */
  readonly rewrite?: ExternalSecretV1Beta1SpecDataFromRewrite[];

  /**
   * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
   *
   * @schema ExternalSecretV1Beta1SpecDataFrom#sourceRef
   */
  readonly sourceRef?: ExternalSecretV1Beta1SpecDataFromSourceRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFrom(obj: ExternalSecretV1Beta1SpecDataFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'extract': toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj.extract),
    'find': toJson_ExternalSecretV1Beta1SpecDataFromFind(obj.find),
    'rewrite': obj.rewrite?.map(y => toJson_ExternalSecretV1Beta1SpecDataFromRewrite(y)),
    'sourceRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj.sourceRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecSecretStoreRef
 */
export interface ExternalSecretV1Beta1SpecSecretStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecSecretStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecSecretStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecSecretStoreRef(obj: ExternalSecretV1Beta1SpecSecretStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * ExternalSecretTarget defines the Kubernetes Secret to be created There can be only one target per ExternalSecret.
 *
 * @schema ExternalSecretV1Beta1SpecTarget
 */
export interface ExternalSecretV1Beta1SpecTarget {
  /**
   * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
   *
   * @default Owner'
   * @schema ExternalSecretV1Beta1SpecTarget#creationPolicy
   */
  readonly creationPolicy?: ExternalSecretV1Beta1SpecTargetCreationPolicy;

  /**
   * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
   *
   * @default Retain'
   * @schema ExternalSecretV1Beta1SpecTarget#deletionPolicy
   */
  readonly deletionPolicy?: ExternalSecretV1Beta1SpecTargetDeletionPolicy;

  /**
   * Immutable defines if the final secret will be immutable
   *
   * @schema ExternalSecretV1Beta1SpecTarget#immutable
   */
  readonly immutable?: boolean;

  /**
   * Name defines the name of the Secret resource to be managed This field is immutable Defaults to the .metadata.name of the ExternalSecret resource
   *
   * @default the .metadata.name of the ExternalSecret resource
   * @schema ExternalSecretV1Beta1SpecTarget#name
   */
  readonly name?: string;

  /**
   * Template defines a blueprint for the created Secret resource.
   *
   * @schema ExternalSecretV1Beta1SpecTarget#template
   */
  readonly template?: ExternalSecretV1Beta1SpecTargetTemplate;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTarget' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTarget(obj: ExternalSecretV1Beta1SpecTarget | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'creationPolicy': obj.creationPolicy,
    'deletionPolicy': obj.deletionPolicy,
    'immutable': obj.immutable,
    'name': obj.name,
    'template': toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj.template),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * RemoteRef points to the remote secret and defines which secret (version/property/..) to fetch.
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRef
 */
export interface ExternalSecretV1Beta1SpecDataRemoteRef {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataRemoteRef#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataRemoteRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataRemoteRef(obj: ExternalSecretV1Beta1SpecDataRemoteRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef allows you to override the source from which the value will pulled from.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   * Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRef(obj: ExternalSecretV1Beta1SpecDataSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to extract multiple key/value pairs from one secret Note: Extract does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtract
 */
export interface ExternalSecretV1Beta1SpecDataFromExtract {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy;

  /**
   * Key is the key used in the Provider, mandatory
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#key
   */
  readonly key: string;

  /**
   * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
   *
   * @default None
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#metadataPolicy
   */
  readonly metadataPolicy?: ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy;

  /**
   * Used to select a specific property of the Provider value (if a map), if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#property
   */
  readonly property?: string;

  /**
   * Used to select a specific version of the Provider value, if supported
   *
   * @schema ExternalSecretV1Beta1SpecDataFromExtract#version
   */
  readonly version?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromExtract' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromExtract(obj: ExternalSecretV1Beta1SpecDataFromExtract | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'key': obj.key,
    'metadataPolicy': obj.metadataPolicy,
    'property': obj.property,
    'version': obj.version,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to find secrets based on tags or regular expressions Note: Find does not support sourceRef.Generator or sourceRef.GeneratorRef.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFind
 */
export interface ExternalSecretV1Beta1SpecDataFromFind {
  /**
   * Used to define a conversion Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#conversionStrategy
   */
  readonly conversionStrategy?: ExternalSecretV1Beta1SpecDataFromFindConversionStrategy;

  /**
   * Used to define a decoding Strategy
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#decodingStrategy
   */
  readonly decodingStrategy?: ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy;

  /**
   * Finds secrets based on the name.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#name
   */
  readonly name?: ExternalSecretV1Beta1SpecDataFromFindName;

  /**
   * A root path to start the find operations.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#path
   */
  readonly path?: string;

  /**
   * Find secrets based on tags.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFind#tags
   */
  readonly tags?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFind' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFind(obj: ExternalSecretV1Beta1SpecDataFromFind | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'conversionStrategy': obj.conversionStrategy,
    'decodingStrategy': obj.decodingStrategy,
    'name': toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj.name),
    'path': obj.path,
    'tags': ((obj.tags) === undefined) ? undefined : (Object.entries(obj.tags).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecDataFromRewrite
 */
export interface ExternalSecretV1Beta1SpecDataFromRewrite {
  /**
   * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#regexp
   */
  readonly regexp?: ExternalSecretV1Beta1SpecDataFromRewriteRegexp;

  /**
   * Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewrite#transform
   */
  readonly transform?: ExternalSecretV1Beta1SpecDataFromRewriteTransform;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewrite' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewrite(obj: ExternalSecretV1Beta1SpecDataFromRewrite | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj.regexp),
    'transform': toJson_ExternalSecretV1Beta1SpecDataFromRewriteTransform(obj.transform),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SourceRef points to a store or generator which contains secret values ready to use. Use this in combination with Extract or Find pull values out of a specific SecretStore. When sourceRef points to a generator Extract or Find is not supported. The generator returns a static map of values
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRef {
  /**
   * GeneratorRef points to a generator custom resource.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#generatorRef
   */
  readonly generatorRef?: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef;

  /**
   * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRef#storeRef
   */
  readonly storeRef?: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'generatorRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(obj.generatorRef),
    'storeRef': toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(obj.storeRef),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * CreationPolicy defines rules on how to create the resulting Secret Defaults to 'Owner'
 *
 * @default Owner'
 * @schema ExternalSecretV1Beta1SpecTargetCreationPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetCreationPolicy {
  /** Owner */
  OWNER = "Owner",
  /** Orphan */
  ORPHAN = "Orphan",
  /** Merge */
  MERGE = "Merge",
  /** None */
  NONE = "None",
}

/**
 * DeletionPolicy defines rules on how to delete the resulting Secret Defaults to 'Retain'
 *
 * @default Retain'
 * @schema ExternalSecretV1Beta1SpecTargetDeletionPolicy
 */
export enum ExternalSecretV1Beta1SpecTargetDeletionPolicy {
  /** Delete */
  DELETE = "Delete",
  /** Merge */
  MERGE = "Merge",
  /** Retain */
  RETAIN = "Retain",
}

/**
 * Template defines a blueprint for the created Secret resource.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplate
 */
export interface ExternalSecretV1Beta1SpecTargetTemplate {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#data
   */
  readonly data?: { [key: string]: string };

  /**
   * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#engineVersion
   */
  readonly engineVersion?: ExternalSecretV1Beta1SpecTargetTemplateEngineVersion;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#mergePolicy
   */
  readonly mergePolicy?: ExternalSecretV1Beta1SpecTargetTemplateMergePolicy;

  /**
   * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
   *
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#metadata
   */
  readonly metadata?: ExternalSecretV1Beta1SpecTargetTemplateMetadata;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#templateFrom
   */
  readonly templateFrom?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplate#type
   */
  readonly type?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplate' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplate(obj: ExternalSecretV1Beta1SpecTargetTemplate | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'data': ((obj.data) === undefined) ? undefined : (Object.entries(obj.data).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'engineVersion': obj.engineVersion,
    'mergePolicy': obj.mergePolicy,
    'metadata': toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(obj.metadata),
    'templateFrom': obj.templateFrom?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(y)),
    'type': obj.type,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy
 */
export enum ExternalSecretV1Beta1SpecDataRemoteRefMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * GeneratorRef points to a generator custom resource.
 * Deprecated: The generatorRef is not implemented in .data[]. this will be removed with v1.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef(obj: ExternalSecretV1Beta1SpecDataSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataSourceRefStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataSourceRefStoreRef(obj: ExternalSecretV1Beta1SpecDataSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Policy for fetching tags/labels from provider secrets, possible options are Fetch, None. Defaults to None
 *
 * @default None
 * @schema ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy
 */
export enum ExternalSecretV1Beta1SpecDataFromExtractMetadataPolicy {
  /** None */
  NONE = "None",
  /** Fetch */
  FETCH = "Fetch",
}

/**
 * Used to define a conversion Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindConversionStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromFindConversionStrategy {
  /** Default */
  DEFAULT = "Default",
  /** Unicode */
  UNICODE = "Unicode",
}

/**
 * Used to define a decoding Strategy
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy
 */
export enum ExternalSecretV1Beta1SpecDataFromFindDecodingStrategy {
  /** Auto */
  AUTO = "Auto",
  /** Base64 */
  BASE64 = "Base64",
  /** Base64URL */
  BASE64_URL = "Base64URL",
  /** None */
  NONE = "None",
}

/**
 * Finds secrets based on the name.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromFindName
 */
export interface ExternalSecretV1Beta1SpecDataFromFindName {
  /**
   * Finds secrets base
   *
   * @schema ExternalSecretV1Beta1SpecDataFromFindName#regexp
   */
  readonly regexp?: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromFindName' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromFindName(obj: ExternalSecretV1Beta1SpecDataFromFindName | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'regexp': obj.regexp,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to rewrite with regular expressions. The resulting key will be the output of a regexp.ReplaceAll operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteRegexp {
  /**
   * Used to define the regular expression of a re.Compiler.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#source
   */
  readonly source: string;

  /**
   * Used to define the target pattern of a ReplaceAll operation.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteRegexp#target
   */
  readonly target: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteRegexp' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteRegexp(obj: ExternalSecretV1Beta1SpecDataFromRewriteRegexp | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'source': obj.source,
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * Used to apply string transformation on the secrets. The resulting key will be the output of the template applied by the operation.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromRewriteTransform
 */
export interface ExternalSecretV1Beta1SpecDataFromRewriteTransform {
  /**
   * Used to define the template to apply on the secret name. `.value ` will specify the secret name in the template.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromRewriteTransform#template
   */
  readonly template: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromRewriteTransform' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromRewriteTransform(obj: ExternalSecretV1Beta1SpecDataFromRewriteTransform | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'template': obj.template,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * GeneratorRef points to a generator custom resource.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef {
  /**
   * Specify the apiVersion of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#apiVersion
   */
  readonly apiVersion?: string;

  /**
   * Specify the Kind of the resource, e.g. Password, ACRAccessToken etc.
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#kind
   */
  readonly kind: string;

  /**
   * Specify the name of the generator resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRefGeneratorRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'apiVersion': obj.apiVersion,
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * SecretStoreRef defines which SecretStore to fetch the ExternalSecret data.
 *
 * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef
 */
export interface ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef {
  /**
   * Kind of the SecretStore resource (SecretStore or ClusterSecretStore) Defaults to `SecretStore`
   *
   * @default SecretStore`
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#kind
   */
  readonly kind?: string;

  /**
   * Name of the SecretStore resource
   *
   * @schema ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef(obj: ExternalSecretV1Beta1SpecDataFromSourceRefStoreRef | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'kind': obj.kind,
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * EngineVersion specifies the template engine version that should be used to compile/execute the template specified in .data and .templateFrom[].
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateEngineVersion
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateEngineVersion {
  /** v1 */
  V1 = "v1",
  /** v2 */
  V2 = "v2",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMergePolicy
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateMergePolicy {
  /** Replace */
  REPLACE = "Replace",
  /** Merge */
  MERGE = "Merge",
}

/**
 * ExternalSecretTemplateMetadata defines metadata fields for the Secret blueprint.
 *
 * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateMetadata {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#annotations
   */
  readonly annotations?: { [key: string]: string };

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateMetadata#labels
   */
  readonly labels?: { [key: string]: string };

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateMetadata' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateMetadata(obj: ExternalSecretV1Beta1SpecTargetTemplateMetadata | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'annotations': ((obj.annotations) === undefined) ? undefined : (Object.entries(obj.annotations).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
    'labels': ((obj.labels) === undefined) ? undefined : (Object.entries(obj.labels).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {})),
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#configMap
   */
  readonly configMap?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#literal
   */
  readonly literal?: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#secret
   */
  readonly secret?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom#target
   */
  readonly target?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFrom | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'configMap': toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(obj.configMap),
    'literal': obj.literal,
    'secret': toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(obj.secret),
    'target': obj.target,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMap | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#items
   */
  readonly items: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems[];

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret#name
   */
  readonly name: string;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecret | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'items': obj.items?.map(y => toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(y)),
    'name': obj.name,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromTarget {
  /** Data */
  DATA = "Data",
  /** Annotations */
  ANNOTATIONS = "Annotations",
  /** Labels */
  LABELS = "Labels",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems#templateAs
   */
  readonly templateAs?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems
 */
export interface ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems {
  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#key
   */
  readonly key: string;

  /**
   * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems#templateAs
   */
  readonly templateAs?: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs;

}

/**
 * Converts an object of type 'ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems' to JSON representation.
 */
/* eslint-disable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */
export function toJson_ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems(obj: ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItems | undefined): Record<string, any> | undefined {
  if (obj === undefined) { return undefined; }
  const result = {
    'key': obj.key,
    'templateAs': obj.templateAs,
  };
  // filter undefined values
  return Object.entries(result).reduce((r, i) => (i[1] === undefined) ? r : ({ ...r, [i[0]]: i[1] }), {});
}
/* eslint-enable max-len, @stylistic/max-len, quote-props, @stylistic/quote-props */

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromConfigMapItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

/**
 * @schema ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs
 */
export enum ExternalSecretV1Beta1SpecTargetTemplateTemplateFromSecretItemsTemplateAs {
  /** Values */
  VALUES = "Values",
  /** KeysAndValues */
  KEYS_AND_VALUES = "KeysAndValues",
}

